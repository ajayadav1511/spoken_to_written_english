// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: semiotic_classes.proto

#ifndef PROTOBUF_semiotic_5fclasses_2eproto__INCLUDED
#define PROTOBUF_semiotic_5fclasses_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace speech {
namespace sparrowhawk {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

class Cardinal;
class Ordinal;
class Fraction;
class Time;
class Decimal;
class Measure;
class Date;
class Money;
class Telephone;
class Electronic;
class Connector;
class Abbreviation;

// ===================================================================

class Cardinal : public ::google::protobuf::Message {
 public:
  Cardinal();
  virtual ~Cardinal();

  Cardinal(const Cardinal& from);

  inline Cardinal& operator=(const Cardinal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cardinal& default_instance();

  void Swap(Cardinal* other);

  // implements Message ----------------------------------------------

  Cardinal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cardinal& from);
  void MergeFrom(const Cardinal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string integer = 1;
  inline bool has_integer() const;
  inline void clear_integer();
  static const int kIntegerFieldNumber = 1;
  inline const ::std::string& integer() const;
  inline void set_integer(const ::std::string& value);
  inline void set_integer(const char* value);
  inline void set_integer(const char* value, size_t size);
  inline ::std::string* mutable_integer();
  inline ::std::string* release_integer();
  inline void set_allocated_integer(::std::string* integer);

  // optional string morphosyntactic_features = 2;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 2;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 3;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 3;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 4;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 4;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // repeated string field_order = 5;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 5;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Cardinal)
 private:
  inline void set_has_integer();
  inline void clear_has_integer();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* integer_;
  ::std::string* morphosyntactic_features_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  bool preserve_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Cardinal* default_instance_;
};
// -------------------------------------------------------------------

class Ordinal : public ::google::protobuf::Message {
 public:
  Ordinal();
  virtual ~Ordinal();

  Ordinal(const Ordinal& from);

  inline Ordinal& operator=(const Ordinal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ordinal& default_instance();

  void Swap(Ordinal* other);

  // implements Message ----------------------------------------------

  Ordinal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ordinal& from);
  void MergeFrom(const Ordinal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string integer = 1;
  inline bool has_integer() const;
  inline void clear_integer();
  static const int kIntegerFieldNumber = 1;
  inline const ::std::string& integer() const;
  inline void set_integer(const ::std::string& value);
  inline void set_integer(const char* value);
  inline void set_integer(const char* value, size_t size);
  inline ::std::string* mutable_integer();
  inline ::std::string* release_integer();
  inline void set_allocated_integer(::std::string* integer);

  // optional string morphosyntactic_features = 2;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 2;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 3;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 3;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 4;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 4;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // repeated string field_order = 5;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 5;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Ordinal)
 private:
  inline void set_has_integer();
  inline void clear_has_integer();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* integer_;
  ::std::string* morphosyntactic_features_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  bool preserve_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Ordinal* default_instance_;
};
// -------------------------------------------------------------------

class Fraction : public ::google::protobuf::Message {
 public:
  Fraction();
  virtual ~Fraction();

  Fraction(const Fraction& from);

  inline Fraction& operator=(const Fraction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fraction& default_instance();

  void Swap(Fraction* other);

  // implements Message ----------------------------------------------

  Fraction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Fraction& from);
  void MergeFrom(const Fraction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string integer_part = 1;
  inline bool has_integer_part() const;
  inline void clear_integer_part();
  static const int kIntegerPartFieldNumber = 1;
  inline const ::std::string& integer_part() const;
  inline void set_integer_part(const ::std::string& value);
  inline void set_integer_part(const char* value);
  inline void set_integer_part(const char* value, size_t size);
  inline ::std::string* mutable_integer_part();
  inline ::std::string* release_integer_part();
  inline void set_allocated_integer_part(::std::string* integer_part);

  // required string numerator = 2;
  inline bool has_numerator() const;
  inline void clear_numerator();
  static const int kNumeratorFieldNumber = 2;
  inline const ::std::string& numerator() const;
  inline void set_numerator(const ::std::string& value);
  inline void set_numerator(const char* value);
  inline void set_numerator(const char* value, size_t size);
  inline ::std::string* mutable_numerator();
  inline ::std::string* release_numerator();
  inline void set_allocated_numerator(::std::string* numerator);

  // required string denominator = 3;
  inline bool has_denominator() const;
  inline void clear_denominator();
  static const int kDenominatorFieldNumber = 3;
  inline const ::std::string& denominator() const;
  inline void set_denominator(const ::std::string& value);
  inline void set_denominator(const char* value);
  inline void set_denominator(const char* value, size_t size);
  inline ::std::string* mutable_denominator();
  inline ::std::string* release_denominator();
  inline void set_allocated_denominator(::std::string* denominator);

  // optional int32 style = 4 [deprecated = true];
  inline bool has_style() const PROTOBUF_DEPRECATED;
  inline void clear_style() PROTOBUF_DEPRECATED;
  static const int kStyleFieldNumber = 4;
  inline ::google::protobuf::int32 style() const PROTOBUF_DEPRECATED;
  inline void set_style(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;

  // optional string morphosyntactic_features = 5;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 5;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 6;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 6;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 7;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 7;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // optional bool negative = 8;
  inline bool has_negative() const;
  inline void clear_negative();
  static const int kNegativeFieldNumber = 8;
  inline bool negative() const;
  inline void set_negative(bool value);

  // repeated string field_order = 9;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 9;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Fraction)
 private:
  inline void set_has_integer_part();
  inline void clear_has_integer_part();
  inline void set_has_numerator();
  inline void clear_has_numerator();
  inline void set_has_denominator();
  inline void clear_has_denominator();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();
  inline void set_has_negative();
  inline void clear_has_negative();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* integer_part_;
  ::std::string* numerator_;
  ::std::string* denominator_;
  ::std::string* morphosyntactic_features_;
  ::google::protobuf::int32 style_;
  bool preserve_order_;
  bool negative_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Fraction* default_instance_;
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  void Swap(Time* other);

  // implements Message ----------------------------------------------

  Time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 hours = 1;
  inline bool has_hours() const;
  inline void clear_hours();
  static const int kHoursFieldNumber = 1;
  inline ::google::protobuf::int32 hours() const;
  inline void set_hours(::google::protobuf::int32 value);

  // optional int32 minutes = 2;
  inline bool has_minutes() const;
  inline void clear_minutes();
  static const int kMinutesFieldNumber = 2;
  inline ::google::protobuf::int32 minutes() const;
  inline void set_minutes(::google::protobuf::int32 value);

  // optional int32 seconds = 3 [deprecated = true];
  inline bool has_seconds() const PROTOBUF_DEPRECATED;
  inline void clear_seconds() PROTOBUF_DEPRECATED;
  static const int kSecondsFieldNumber = 3;
  inline ::google::protobuf::int32 seconds() const PROTOBUF_DEPRECATED;
  inline void set_seconds(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;

  // optional bool speak_period = 4;
  inline bool has_speak_period() const;
  inline void clear_speak_period();
  static const int kSpeakPeriodFieldNumber = 4;
  inline bool speak_period() const;
  inline void set_speak_period(bool value);

  // optional string suffix = 5 [deprecated = true];
  inline bool has_suffix() const PROTOBUF_DEPRECATED;
  inline void clear_suffix() PROTOBUF_DEPRECATED;
  static const int kSuffixFieldNumber = 5;
  inline const ::std::string& suffix() const PROTOBUF_DEPRECATED;
  inline void set_suffix(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_suffix(const char* value) PROTOBUF_DEPRECATED;
  inline void set_suffix(const char* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_suffix() PROTOBUF_DEPRECATED;
  inline ::std::string* release_suffix() PROTOBUF_DEPRECATED;
  inline void set_allocated_suffix(::std::string* suffix) PROTOBUF_DEPRECATED;

  // optional int32 style = 6 [deprecated = true];
  inline bool has_style() const PROTOBUF_DEPRECATED;
  inline void clear_style() PROTOBUF_DEPRECATED;
  static const int kStyleFieldNumber = 6;
  inline ::google::protobuf::int32 style() const PROTOBUF_DEPRECATED;
  inline void set_style(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;

  // optional string zone = 7;
  inline bool has_zone() const;
  inline void clear_zone();
  static const int kZoneFieldNumber = 7;
  inline const ::std::string& zone() const;
  inline void set_zone(const ::std::string& value);
  inline void set_zone(const char* value);
  inline void set_zone(const char* value, size_t size);
  inline ::std::string* mutable_zone();
  inline ::std::string* release_zone();
  inline void set_allocated_zone(::std::string* zone);

  // optional string morphosyntactic_features = 9;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 9;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 10;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 10;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 11;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 11;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // repeated string field_order = 12;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 12;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Time)
 private:
  inline void set_has_hours();
  inline void clear_has_hours();
  inline void set_has_minutes();
  inline void clear_has_minutes();
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_speak_period();
  inline void clear_has_speak_period();
  inline void set_has_suffix();
  inline void clear_has_suffix();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_zone();
  inline void clear_has_zone();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 hours_;
  ::google::protobuf::int32 minutes_;
  ::google::protobuf::int32 seconds_;
  ::google::protobuf::int32 style_;
  ::std::string* suffix_;
  ::std::string* zone_;
  ::std::string* morphosyntactic_features_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  bool speak_period_;
  bool preserve_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class Decimal : public ::google::protobuf::Message {
 public:
  Decimal();
  virtual ~Decimal();

  Decimal(const Decimal& from);

  inline Decimal& operator=(const Decimal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Decimal& default_instance();

  void Swap(Decimal* other);

  // implements Message ----------------------------------------------

  Decimal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Decimal& from);
  void MergeFrom(const Decimal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool negative = 1;
  inline bool has_negative() const;
  inline void clear_negative();
  static const int kNegativeFieldNumber = 1;
  inline bool negative() const;
  inline void set_negative(bool value);

  // optional string integer_part = 2;
  inline bool has_integer_part() const;
  inline void clear_integer_part();
  static const int kIntegerPartFieldNumber = 2;
  inline const ::std::string& integer_part() const;
  inline void set_integer_part(const ::std::string& value);
  inline void set_integer_part(const char* value);
  inline void set_integer_part(const char* value, size_t size);
  inline ::std::string* mutable_integer_part();
  inline ::std::string* release_integer_part();
  inline void set_allocated_integer_part(::std::string* integer_part);

  // optional string fractional_part = 3;
  inline bool has_fractional_part() const;
  inline void clear_fractional_part();
  static const int kFractionalPartFieldNumber = 3;
  inline const ::std::string& fractional_part() const;
  inline void set_fractional_part(const ::std::string& value);
  inline void set_fractional_part(const char* value);
  inline void set_fractional_part(const char* value, size_t size);
  inline ::std::string* mutable_fractional_part();
  inline ::std::string* release_fractional_part();
  inline void set_allocated_fractional_part(::std::string* fractional_part);

  // optional string quantity = 4;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  inline const ::std::string& quantity() const;
  inline void set_quantity(const ::std::string& value);
  inline void set_quantity(const char* value);
  inline void set_quantity(const char* value, size_t size);
  inline ::std::string* mutable_quantity();
  inline ::std::string* release_quantity();
  inline void set_allocated_quantity(::std::string* quantity);

  // optional string exponent = 5;
  inline bool has_exponent() const;
  inline void clear_exponent();
  static const int kExponentFieldNumber = 5;
  inline const ::std::string& exponent() const;
  inline void set_exponent(const ::std::string& value);
  inline void set_exponent(const char* value);
  inline void set_exponent(const char* value, size_t size);
  inline ::std::string* mutable_exponent();
  inline ::std::string* release_exponent();
  inline void set_allocated_exponent(::std::string* exponent);

  // optional int32 style = 6 [deprecated = true];
  inline bool has_style() const PROTOBUF_DEPRECATED;
  inline void clear_style() PROTOBUF_DEPRECATED;
  static const int kStyleFieldNumber = 6;
  inline ::google::protobuf::int32 style() const PROTOBUF_DEPRECATED;
  inline void set_style(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;

  // optional string morphosyntactic_features = 7;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 7;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 8;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 8;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 9;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 9;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // repeated string field_order = 10;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 10;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Decimal)
 private:
  inline void set_has_negative();
  inline void clear_has_negative();
  inline void set_has_integer_part();
  inline void clear_has_integer_part();
  inline void set_has_fractional_part();
  inline void clear_has_fractional_part();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_exponent();
  inline void clear_has_exponent();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* integer_part_;
  ::std::string* fractional_part_;
  ::std::string* quantity_;
  ::std::string* exponent_;
  bool negative_;
  bool preserve_order_;
  ::google::protobuf::int32 style_;
  ::std::string* morphosyntactic_features_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Decimal* default_instance_;
};
// -------------------------------------------------------------------

class Measure : public ::google::protobuf::Message {
 public:
  Measure();
  virtual ~Measure();

  Measure(const Measure& from);

  inline Measure& operator=(const Measure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Measure& default_instance();

  void Swap(Measure* other);

  // implements Message ----------------------------------------------

  Measure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Measure& from);
  void MergeFrom(const Measure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .speech.sparrowhawk.Decimal decimal = 1;
  inline bool has_decimal() const;
  inline void clear_decimal();
  static const int kDecimalFieldNumber = 1;
  inline const ::speech::sparrowhawk::Decimal& decimal() const;
  inline ::speech::sparrowhawk::Decimal* mutable_decimal();
  inline ::speech::sparrowhawk::Decimal* release_decimal();
  inline void set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal);

  // optional .speech.sparrowhawk.Fraction fraction = 2;
  inline bool has_fraction() const;
  inline void clear_fraction();
  static const int kFractionFieldNumber = 2;
  inline const ::speech::sparrowhawk::Fraction& fraction() const;
  inline ::speech::sparrowhawk::Fraction* mutable_fraction();
  inline ::speech::sparrowhawk::Fraction* release_fraction();
  inline void set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction);

  // optional .speech.sparrowhawk.Cardinal cardinal = 3;
  inline bool has_cardinal() const;
  inline void clear_cardinal();
  static const int kCardinalFieldNumber = 3;
  inline const ::speech::sparrowhawk::Cardinal& cardinal() const;
  inline ::speech::sparrowhawk::Cardinal* mutable_cardinal();
  inline ::speech::sparrowhawk::Cardinal* release_cardinal();
  inline void set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal);

  // optional string units = 4;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 4;
  inline const ::std::string& units() const;
  inline void set_units(const ::std::string& value);
  inline void set_units(const char* value);
  inline void set_units(const char* value, size_t size);
  inline ::std::string* mutable_units();
  inline ::std::string* release_units();
  inline void set_allocated_units(::std::string* units);

  // optional int32 style = 5 [deprecated = true];
  inline bool has_style() const PROTOBUF_DEPRECATED;
  inline void clear_style() PROTOBUF_DEPRECATED;
  static const int kStyleFieldNumber = 5;
  inline ::google::protobuf::int32 style() const PROTOBUF_DEPRECATED;
  inline void set_style(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;

  // optional string morphosyntactic_features = 6;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 6;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 7;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 7;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 8;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 8;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // repeated string field_order = 9;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 9;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Measure)
 private:
  inline void set_has_decimal();
  inline void clear_has_decimal();
  inline void set_has_fraction();
  inline void clear_has_fraction();
  inline void set_has_cardinal();
  inline void clear_has_cardinal();
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::speech::sparrowhawk::Decimal* decimal_;
  ::speech::sparrowhawk::Fraction* fraction_;
  ::speech::sparrowhawk::Cardinal* cardinal_;
  ::std::string* units_;
  ::std::string* morphosyntactic_features_;
  ::google::protobuf::int32 style_;
  bool preserve_order_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Measure* default_instance_;
};
// -------------------------------------------------------------------

class Date : public ::google::protobuf::Message {
 public:
  Date();
  virtual ~Date();

  Date(const Date& from);

  inline Date& operator=(const Date& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Date& default_instance();

  void Swap(Date* other);

  // implements Message ----------------------------------------------

  Date* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Date& from);
  void MergeFrom(const Date& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string weekday = 1;
  inline bool has_weekday() const;
  inline void clear_weekday();
  static const int kWeekdayFieldNumber = 1;
  inline const ::std::string& weekday() const;
  inline void set_weekday(const ::std::string& value);
  inline void set_weekday(const char* value);
  inline void set_weekday(const char* value, size_t size);
  inline ::std::string* mutable_weekday();
  inline ::std::string* release_weekday();
  inline void set_allocated_weekday(::std::string* weekday);

  // optional string day = 2;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 2;
  inline const ::std::string& day() const;
  inline void set_day(const ::std::string& value);
  inline void set_day(const char* value);
  inline void set_day(const char* value, size_t size);
  inline ::std::string* mutable_day();
  inline ::std::string* release_day();
  inline void set_allocated_day(::std::string* day);

  // optional string month = 3;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 3;
  inline const ::std::string& month() const;
  inline void set_month(const ::std::string& value);
  inline void set_month(const char* value);
  inline void set_month(const char* value, size_t size);
  inline ::std::string* mutable_month();
  inline ::std::string* release_month();
  inline void set_allocated_month(::std::string* month);

  // optional string year = 4;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 4;
  inline const ::std::string& year() const;
  inline void set_year(const ::std::string& value);
  inline void set_year(const char* value);
  inline void set_year(const char* value, size_t size);
  inline ::std::string* mutable_year();
  inline ::std::string* release_year();
  inline void set_allocated_year(::std::string* year);

  // optional int32 style = 5 [deprecated = true];
  inline bool has_style() const PROTOBUF_DEPRECATED;
  inline void clear_style() PROTOBUF_DEPRECATED;
  static const int kStyleFieldNumber = 5;
  inline ::google::protobuf::int32 style() const PROTOBUF_DEPRECATED;
  inline void set_style(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;

  // optional string text = 6 [deprecated = true];
  inline bool has_text() const PROTOBUF_DEPRECATED;
  inline void clear_text() PROTOBUF_DEPRECATED;
  static const int kTextFieldNumber = 6;
  inline const ::std::string& text() const PROTOBUF_DEPRECATED;
  inline void set_text(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_text(const char* value) PROTOBUF_DEPRECATED;
  inline void set_text(const char* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_text() PROTOBUF_DEPRECATED;
  inline ::std::string* release_text() PROTOBUF_DEPRECATED;
  inline void set_allocated_text(::std::string* text) PROTOBUF_DEPRECATED;

  // optional bool short_year = 7 [deprecated = true];
  inline bool has_short_year() const PROTOBUF_DEPRECATED;
  inline void clear_short_year() PROTOBUF_DEPRECATED;
  static const int kShortYearFieldNumber = 7;
  inline bool short_year() const PROTOBUF_DEPRECATED;
  inline void set_short_year(bool value) PROTOBUF_DEPRECATED;

  // optional string era = 8;
  inline bool has_era() const;
  inline void clear_era();
  static const int kEraFieldNumber = 8;
  inline const ::std::string& era() const;
  inline void set_era(const ::std::string& value);
  inline void set_era(const char* value);
  inline void set_era(const char* value, size_t size);
  inline ::std::string* mutable_era();
  inline ::std::string* release_era();
  inline void set_allocated_era(::std::string* era);

  // optional string morphosyntactic_features = 9;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 9;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 10;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 10;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 11;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 11;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // repeated string field_order = 12;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 12;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Date)
 private:
  inline void set_has_weekday();
  inline void clear_has_weekday();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_short_year();
  inline void clear_has_short_year();
  inline void set_has_era();
  inline void clear_has_era();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* weekday_;
  ::std::string* day_;
  ::std::string* month_;
  ::std::string* year_;
  ::std::string* text_;
  ::google::protobuf::int32 style_;
  bool short_year_;
  bool preserve_order_;
  ::std::string* era_;
  ::std::string* morphosyntactic_features_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Date* default_instance_;
};
// -------------------------------------------------------------------

class Money : public ::google::protobuf::Message {
 public:
  Money();
  virtual ~Money();

  Money(const Money& from);

  inline Money& operator=(const Money& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Money& default_instance();

  void Swap(Money* other);

  // implements Message ----------------------------------------------

  Money* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Money& from);
  void MergeFrom(const Money& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .speech.sparrowhawk.Decimal amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline const ::speech::sparrowhawk::Decimal& amount() const;
  inline ::speech::sparrowhawk::Decimal* mutable_amount();
  inline ::speech::sparrowhawk::Decimal* release_amount();
  inline void set_allocated_amount(::speech::sparrowhawk::Decimal* amount);

  // optional int64 quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int64 quantity() const;
  inline void set_quantity(::google::protobuf::int64 value);

  // required string currency = 3;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 3;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional int32 style = 4 [deprecated = true];
  inline bool has_style() const PROTOBUF_DEPRECATED;
  inline void clear_style() PROTOBUF_DEPRECATED;
  static const int kStyleFieldNumber = 4;
  inline ::google::protobuf::int32 style() const PROTOBUF_DEPRECATED;
  inline void set_style(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;

  // optional string morphosyntactic_features = 5;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 5;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 6;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 6;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 7;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 7;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // repeated string field_order = 8;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 8;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Money)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::speech::sparrowhawk::Decimal* amount_;
  ::google::protobuf::int64 quantity_;
  ::std::string* currency_;
  ::std::string* morphosyntactic_features_;
  ::google::protobuf::int32 style_;
  bool preserve_order_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Money* default_instance_;
};
// -------------------------------------------------------------------

class Telephone : public ::google::protobuf::Message {
 public:
  Telephone();
  virtual ~Telephone();

  Telephone(const Telephone& from);

  inline Telephone& operator=(const Telephone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telephone& default_instance();

  void Swap(Telephone* other);

  // implements Message ----------------------------------------------

  Telephone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Telephone& from);
  void MergeFrom(const Telephone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string country_code = 1;
  inline bool has_country_code() const;
  inline void clear_country_code();
  static const int kCountryCodeFieldNumber = 1;
  inline const ::std::string& country_code() const;
  inline void set_country_code(const ::std::string& value);
  inline void set_country_code(const char* value);
  inline void set_country_code(const char* value, size_t size);
  inline ::std::string* mutable_country_code();
  inline ::std::string* release_country_code();
  inline void set_allocated_country_code(::std::string* country_code);

  // repeated string number_part = 2;
  inline int number_part_size() const;
  inline void clear_number_part();
  static const int kNumberPartFieldNumber = 2;
  inline const ::std::string& number_part(int index) const;
  inline ::std::string* mutable_number_part(int index);
  inline void set_number_part(int index, const ::std::string& value);
  inline void set_number_part(int index, const char* value);
  inline void set_number_part(int index, const char* value, size_t size);
  inline ::std::string* add_number_part();
  inline void add_number_part(const ::std::string& value);
  inline void add_number_part(const char* value);
  inline void add_number_part(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& number_part() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_number_part();

  // optional string extension = 3;
  inline bool has_extension() const;
  inline void clear_extension();
  static const int kExtensionFieldNumber = 3;
  inline const ::std::string& extension() const;
  inline void set_extension(const ::std::string& value);
  inline void set_extension(const char* value);
  inline void set_extension(const char* value, size_t size);
  inline ::std::string* mutable_extension();
  inline ::std::string* release_extension();
  inline void set_allocated_extension(::std::string* extension);

  // optional int32 style = 4 [deprecated = true];
  inline bool has_style() const PROTOBUF_DEPRECATED;
  inline void clear_style() PROTOBUF_DEPRECATED;
  static const int kStyleFieldNumber = 4;
  inline ::google::protobuf::int32 style() const PROTOBUF_DEPRECATED;
  inline void set_style(::google::protobuf::int32 value) PROTOBUF_DEPRECATED;

  // optional string morphosyntactic_features = 5;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 5;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 6;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 6;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 7;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 7;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // repeated string field_order = 8;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 8;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Telephone)
 private:
  inline void set_has_country_code();
  inline void clear_has_country_code();
  inline void set_has_extension();
  inline void clear_has_extension();
  inline void set_has_style();
  inline void clear_has_style();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* country_code_;
  ::google::protobuf::RepeatedPtrField< ::std::string> number_part_;
  ::std::string* extension_;
  ::std::string* morphosyntactic_features_;
  ::google::protobuf::int32 style_;
  bool preserve_order_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Telephone* default_instance_;
};
// -------------------------------------------------------------------

class Electronic : public ::google::protobuf::Message {
 public:
  Electronic();
  virtual ~Electronic();

  Electronic(const Electronic& from);

  inline Electronic& operator=(const Electronic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Electronic& default_instance();

  void Swap(Electronic* other);

  // implements Message ----------------------------------------------

  Electronic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Electronic& from);
  void MergeFrom(const Electronic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string protocol = 1;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string domain = 4;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 4;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional int32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional string path = 6;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 6;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string query_string = 7;
  inline bool has_query_string() const;
  inline void clear_query_string();
  static const int kQueryStringFieldNumber = 7;
  inline const ::std::string& query_string() const;
  inline void set_query_string(const ::std::string& value);
  inline void set_query_string(const char* value);
  inline void set_query_string(const char* value, size_t size);
  inline ::std::string* mutable_query_string();
  inline ::std::string* release_query_string();
  inline void set_allocated_query_string(::std::string* query_string);

  // optional string fragment_id = 8;
  inline bool has_fragment_id() const;
  inline void clear_fragment_id();
  static const int kFragmentIdFieldNumber = 8;
  inline const ::std::string& fragment_id() const;
  inline void set_fragment_id(const ::std::string& value);
  inline void set_fragment_id(const char* value);
  inline void set_fragment_id(const char* value, size_t size);
  inline ::std::string* mutable_fragment_id();
  inline ::std::string* release_fragment_id();
  inline void set_allocated_fragment_id(::std::string* fragment_id);

  // optional string morphosyntactic_features = 9;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 9;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional bool preserve_order = 10;
  inline bool has_preserve_order() const;
  inline void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 10;
  inline bool preserve_order() const;
  inline void set_preserve_order(bool value);

  // optional string code_switch = 11;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 11;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // repeated string field_order = 12;
  inline int field_order_size() const;
  inline void clear_field_order();
  static const int kFieldOrderFieldNumber = 12;
  inline const ::std::string& field_order(int index) const;
  inline ::std::string* mutable_field_order(int index);
  inline void set_field_order(int index, const ::std::string& value);
  inline void set_field_order(int index, const char* value);
  inline void set_field_order(int index, const char* value, size_t size);
  inline ::std::string* add_field_order();
  inline void add_field_order(const ::std::string& value);
  inline void add_field_order(const char* value);
  inline void add_field_order(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Electronic)
 private:
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_query_string();
  inline void clear_has_query_string();
  inline void set_has_fragment_id();
  inline void clear_has_fragment_id();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_preserve_order();
  inline void clear_has_preserve_order();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* protocol_;
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* domain_;
  ::std::string* path_;
  ::std::string* query_string_;
  ::google::protobuf::int32 port_;
  bool preserve_order_;
  ::std::string* fragment_id_;
  ::std::string* morphosyntactic_features_;
  ::std::string* code_switch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Electronic* default_instance_;
};
// -------------------------------------------------------------------

class Connector : public ::google::protobuf::Message {
 public:
  Connector();
  virtual ~Connector();

  Connector(const Connector& from);

  inline Connector& operator=(const Connector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connector& default_instance();

  void Swap(Connector* other);

  // implements Message ----------------------------------------------

  Connector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connector& from);
  void MergeFrom(const Connector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string morphosyntactic_features = 2;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 2;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 3;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 3;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Connector)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::std::string* morphosyntactic_features_;
  ::std::string* code_switch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Connector* default_instance_;
};
// -------------------------------------------------------------------

class Abbreviation : public ::google::protobuf::Message {
 public:
  Abbreviation();
  virtual ~Abbreviation();

  Abbreviation(const Abbreviation& from);

  inline Abbreviation& operator=(const Abbreviation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Abbreviation& default_instance();

  void Swap(Abbreviation* other);

  // implements Message ----------------------------------------------

  Abbreviation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Abbreviation& from);
  void MergeFrom(const Abbreviation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string morphosyntactic_features = 2;
  inline bool has_morphosyntactic_features() const;
  inline void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 2;
  inline const ::std::string& morphosyntactic_features() const;
  inline void set_morphosyntactic_features(const ::std::string& value);
  inline void set_morphosyntactic_features(const char* value);
  inline void set_morphosyntactic_features(const char* value, size_t size);
  inline ::std::string* mutable_morphosyntactic_features();
  inline ::std::string* release_morphosyntactic_features();
  inline void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 3;
  inline bool has_code_switch() const;
  inline void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 3;
  inline const ::std::string& code_switch() const;
  inline void set_code_switch(const ::std::string& value);
  inline void set_code_switch(const char* value);
  inline void set_code_switch(const char* value, size_t size);
  inline ::std::string* mutable_code_switch();
  inline ::std::string* release_code_switch();
  inline void set_allocated_code_switch(::std::string* code_switch);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Abbreviation)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_morphosyntactic_features();
  inline void clear_has_morphosyntactic_features();
  inline void set_has_code_switch();
  inline void clear_has_code_switch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::std::string* morphosyntactic_features_;
  ::std::string* code_switch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_AssignDesc_semiotic_5fclasses_2eproto();
  friend void protobuf_ShutdownFile_semiotic_5fclasses_2eproto();

  void InitAsDefaultInstance();
  static Abbreviation* default_instance_;
};
// ===================================================================


// ===================================================================

// Cardinal

// required string integer = 1;
inline bool Cardinal::has_integer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cardinal::set_has_integer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cardinal::clear_has_integer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cardinal::clear_integer() {
  if (integer_ != &::google::protobuf::internal::kEmptyString) {
    integer_->clear();
  }
  clear_has_integer();
}
inline const ::std::string& Cardinal::integer() const {
  return *integer_;
}
inline void Cardinal::set_integer(const ::std::string& value) {
  set_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    integer_ = new ::std::string;
  }
  integer_->assign(value);
}
inline void Cardinal::set_integer(const char* value) {
  set_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    integer_ = new ::std::string;
  }
  integer_->assign(value);
}
inline void Cardinal::set_integer(const char* value, size_t size) {
  set_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    integer_ = new ::std::string;
  }
  integer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Cardinal::mutable_integer() {
  set_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    integer_ = new ::std::string;
  }
  return integer_;
}
inline ::std::string* Cardinal::release_integer() {
  clear_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = integer_;
    integer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Cardinal::set_allocated_integer(::std::string* integer) {
  if (integer_ != &::google::protobuf::internal::kEmptyString) {
    delete integer_;
  }
  if (integer) {
    set_has_integer();
    integer_ = integer;
  } else {
    clear_has_integer();
    integer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string morphosyntactic_features = 2;
inline bool Cardinal::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cardinal::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cardinal::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cardinal::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Cardinal::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Cardinal::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Cardinal::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Cardinal::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Cardinal::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Cardinal::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Cardinal::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 3;
inline bool Cardinal::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cardinal::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cardinal::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cardinal::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Cardinal::preserve_order() const {
  return preserve_order_;
}
inline void Cardinal::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 4;
inline bool Cardinal::has_code_switch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cardinal::set_has_code_switch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Cardinal::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Cardinal::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Cardinal::code_switch() const {
  return *code_switch_;
}
inline void Cardinal::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Cardinal::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Cardinal::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Cardinal::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Cardinal::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Cardinal::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string field_order = 5;
inline int Cardinal::field_order_size() const {
  return field_order_.size();
}
inline void Cardinal::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Cardinal::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Cardinal::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Cardinal::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Cardinal::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Cardinal::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Cardinal::add_field_order() {
  return field_order_.Add();
}
inline void Cardinal::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Cardinal::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Cardinal::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Cardinal::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Cardinal::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Ordinal

// required string integer = 1;
inline bool Ordinal::has_integer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ordinal::set_has_integer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ordinal::clear_has_integer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ordinal::clear_integer() {
  if (integer_ != &::google::protobuf::internal::kEmptyString) {
    integer_->clear();
  }
  clear_has_integer();
}
inline const ::std::string& Ordinal::integer() const {
  return *integer_;
}
inline void Ordinal::set_integer(const ::std::string& value) {
  set_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    integer_ = new ::std::string;
  }
  integer_->assign(value);
}
inline void Ordinal::set_integer(const char* value) {
  set_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    integer_ = new ::std::string;
  }
  integer_->assign(value);
}
inline void Ordinal::set_integer(const char* value, size_t size) {
  set_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    integer_ = new ::std::string;
  }
  integer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ordinal::mutable_integer() {
  set_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    integer_ = new ::std::string;
  }
  return integer_;
}
inline ::std::string* Ordinal::release_integer() {
  clear_has_integer();
  if (integer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = integer_;
    integer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ordinal::set_allocated_integer(::std::string* integer) {
  if (integer_ != &::google::protobuf::internal::kEmptyString) {
    delete integer_;
  }
  if (integer) {
    set_has_integer();
    integer_ = integer;
  } else {
    clear_has_integer();
    integer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string morphosyntactic_features = 2;
inline bool Ordinal::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ordinal::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ordinal::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ordinal::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Ordinal::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Ordinal::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Ordinal::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Ordinal::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ordinal::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Ordinal::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ordinal::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 3;
inline bool Ordinal::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ordinal::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ordinal::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ordinal::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Ordinal::preserve_order() const {
  return preserve_order_;
}
inline void Ordinal::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 4;
inline bool Ordinal::has_code_switch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ordinal::set_has_code_switch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ordinal::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ordinal::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Ordinal::code_switch() const {
  return *code_switch_;
}
inline void Ordinal::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Ordinal::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Ordinal::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ordinal::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Ordinal::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ordinal::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string field_order = 5;
inline int Ordinal::field_order_size() const {
  return field_order_.size();
}
inline void Ordinal::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Ordinal::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Ordinal::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Ordinal::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Ordinal::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Ordinal::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ordinal::add_field_order() {
  return field_order_.Add();
}
inline void Ordinal::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Ordinal::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Ordinal::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Ordinal::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Ordinal::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Fraction

// optional string integer_part = 1;
inline bool Fraction::has_integer_part() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fraction::set_has_integer_part() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fraction::clear_has_integer_part() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fraction::clear_integer_part() {
  if (integer_part_ != &::google::protobuf::internal::kEmptyString) {
    integer_part_->clear();
  }
  clear_has_integer_part();
}
inline const ::std::string& Fraction::integer_part() const {
  return *integer_part_;
}
inline void Fraction::set_integer_part(const ::std::string& value) {
  set_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    integer_part_ = new ::std::string;
  }
  integer_part_->assign(value);
}
inline void Fraction::set_integer_part(const char* value) {
  set_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    integer_part_ = new ::std::string;
  }
  integer_part_->assign(value);
}
inline void Fraction::set_integer_part(const char* value, size_t size) {
  set_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    integer_part_ = new ::std::string;
  }
  integer_part_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Fraction::mutable_integer_part() {
  set_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    integer_part_ = new ::std::string;
  }
  return integer_part_;
}
inline ::std::string* Fraction::release_integer_part() {
  clear_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = integer_part_;
    integer_part_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Fraction::set_allocated_integer_part(::std::string* integer_part) {
  if (integer_part_ != &::google::protobuf::internal::kEmptyString) {
    delete integer_part_;
  }
  if (integer_part) {
    set_has_integer_part();
    integer_part_ = integer_part;
  } else {
    clear_has_integer_part();
    integer_part_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string numerator = 2;
inline bool Fraction::has_numerator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fraction::set_has_numerator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Fraction::clear_has_numerator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Fraction::clear_numerator() {
  if (numerator_ != &::google::protobuf::internal::kEmptyString) {
    numerator_->clear();
  }
  clear_has_numerator();
}
inline const ::std::string& Fraction::numerator() const {
  return *numerator_;
}
inline void Fraction::set_numerator(const ::std::string& value) {
  set_has_numerator();
  if (numerator_ == &::google::protobuf::internal::kEmptyString) {
    numerator_ = new ::std::string;
  }
  numerator_->assign(value);
}
inline void Fraction::set_numerator(const char* value) {
  set_has_numerator();
  if (numerator_ == &::google::protobuf::internal::kEmptyString) {
    numerator_ = new ::std::string;
  }
  numerator_->assign(value);
}
inline void Fraction::set_numerator(const char* value, size_t size) {
  set_has_numerator();
  if (numerator_ == &::google::protobuf::internal::kEmptyString) {
    numerator_ = new ::std::string;
  }
  numerator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Fraction::mutable_numerator() {
  set_has_numerator();
  if (numerator_ == &::google::protobuf::internal::kEmptyString) {
    numerator_ = new ::std::string;
  }
  return numerator_;
}
inline ::std::string* Fraction::release_numerator() {
  clear_has_numerator();
  if (numerator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = numerator_;
    numerator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Fraction::set_allocated_numerator(::std::string* numerator) {
  if (numerator_ != &::google::protobuf::internal::kEmptyString) {
    delete numerator_;
  }
  if (numerator) {
    set_has_numerator();
    numerator_ = numerator;
  } else {
    clear_has_numerator();
    numerator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string denominator = 3;
inline bool Fraction::has_denominator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fraction::set_has_denominator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Fraction::clear_has_denominator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Fraction::clear_denominator() {
  if (denominator_ != &::google::protobuf::internal::kEmptyString) {
    denominator_->clear();
  }
  clear_has_denominator();
}
inline const ::std::string& Fraction::denominator() const {
  return *denominator_;
}
inline void Fraction::set_denominator(const ::std::string& value) {
  set_has_denominator();
  if (denominator_ == &::google::protobuf::internal::kEmptyString) {
    denominator_ = new ::std::string;
  }
  denominator_->assign(value);
}
inline void Fraction::set_denominator(const char* value) {
  set_has_denominator();
  if (denominator_ == &::google::protobuf::internal::kEmptyString) {
    denominator_ = new ::std::string;
  }
  denominator_->assign(value);
}
inline void Fraction::set_denominator(const char* value, size_t size) {
  set_has_denominator();
  if (denominator_ == &::google::protobuf::internal::kEmptyString) {
    denominator_ = new ::std::string;
  }
  denominator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Fraction::mutable_denominator() {
  set_has_denominator();
  if (denominator_ == &::google::protobuf::internal::kEmptyString) {
    denominator_ = new ::std::string;
  }
  return denominator_;
}
inline ::std::string* Fraction::release_denominator() {
  clear_has_denominator();
  if (denominator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = denominator_;
    denominator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Fraction::set_allocated_denominator(::std::string* denominator) {
  if (denominator_ != &::google::protobuf::internal::kEmptyString) {
    delete denominator_;
  }
  if (denominator) {
    set_has_denominator();
    denominator_ = denominator;
  } else {
    clear_has_denominator();
    denominator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 style = 4 [deprecated = true];
inline bool Fraction::has_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fraction::set_has_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Fraction::clear_has_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Fraction::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Fraction::style() const {
  return style_;
}
inline void Fraction::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
}

// optional string morphosyntactic_features = 5;
inline bool Fraction::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fraction::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Fraction::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Fraction::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Fraction::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Fraction::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Fraction::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Fraction::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Fraction::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Fraction::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Fraction::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 6;
inline bool Fraction::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Fraction::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Fraction::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Fraction::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Fraction::preserve_order() const {
  return preserve_order_;
}
inline void Fraction::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 7;
inline bool Fraction::has_code_switch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Fraction::set_has_code_switch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Fraction::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Fraction::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Fraction::code_switch() const {
  return *code_switch_;
}
inline void Fraction::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Fraction::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Fraction::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Fraction::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Fraction::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Fraction::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool negative = 8;
inline bool Fraction::has_negative() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Fraction::set_has_negative() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Fraction::clear_has_negative() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Fraction::clear_negative() {
  negative_ = false;
  clear_has_negative();
}
inline bool Fraction::negative() const {
  return negative_;
}
inline void Fraction::set_negative(bool value) {
  set_has_negative();
  negative_ = value;
}

// repeated string field_order = 9;
inline int Fraction::field_order_size() const {
  return field_order_.size();
}
inline void Fraction::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Fraction::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Fraction::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Fraction::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Fraction::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Fraction::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Fraction::add_field_order() {
  return field_order_.Add();
}
inline void Fraction::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Fraction::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Fraction::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Fraction::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Fraction::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Time

// optional int32 hours = 1;
inline bool Time::has_hours() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_hours() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_hours() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_hours() {
  hours_ = 0;
  clear_has_hours();
}
inline ::google::protobuf::int32 Time::hours() const {
  return hours_;
}
inline void Time::set_hours(::google::protobuf::int32 value) {
  set_has_hours();
  hours_ = value;
}

// optional int32 minutes = 2;
inline bool Time::has_minutes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_minutes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_minutes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_minutes() {
  minutes_ = 0;
  clear_has_minutes();
}
inline ::google::protobuf::int32 Time::minutes() const {
  return minutes_;
}
inline void Time::set_minutes(::google::protobuf::int32 value) {
  set_has_minutes();
  minutes_ = value;
}

// optional int32 seconds = 3 [deprecated = true];
inline bool Time::has_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Time::set_has_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Time::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Time::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 Time::seconds() const {
  return seconds_;
}
inline void Time::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
}

// optional bool speak_period = 4;
inline bool Time::has_speak_period() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Time::set_has_speak_period() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Time::clear_has_speak_period() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Time::clear_speak_period() {
  speak_period_ = false;
  clear_has_speak_period();
}
inline bool Time::speak_period() const {
  return speak_period_;
}
inline void Time::set_speak_period(bool value) {
  set_has_speak_period();
  speak_period_ = value;
}

// optional string suffix = 5 [deprecated = true];
inline bool Time::has_suffix() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Time::set_has_suffix() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Time::clear_has_suffix() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Time::clear_suffix() {
  if (suffix_ != &::google::protobuf::internal::kEmptyString) {
    suffix_->clear();
  }
  clear_has_suffix();
}
inline const ::std::string& Time::suffix() const {
  return *suffix_;
}
inline void Time::set_suffix(const ::std::string& value) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(value);
}
inline void Time::set_suffix(const char* value) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(value);
}
inline void Time::set_suffix(const char* value, size_t size) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Time::mutable_suffix() {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  return suffix_;
}
inline ::std::string* Time::release_suffix() {
  clear_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suffix_;
    suffix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Time::set_allocated_suffix(::std::string* suffix) {
  if (suffix_ != &::google::protobuf::internal::kEmptyString) {
    delete suffix_;
  }
  if (suffix) {
    set_has_suffix();
    suffix_ = suffix;
  } else {
    clear_has_suffix();
    suffix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 style = 6 [deprecated = true];
inline bool Time::has_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Time::set_has_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Time::clear_has_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Time::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Time::style() const {
  return style_;
}
inline void Time::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
}

// optional string zone = 7;
inline bool Time::has_zone() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Time::set_has_zone() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Time::clear_has_zone() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Time::clear_zone() {
  if (zone_ != &::google::protobuf::internal::kEmptyString) {
    zone_->clear();
  }
  clear_has_zone();
}
inline const ::std::string& Time::zone() const {
  return *zone_;
}
inline void Time::set_zone(const ::std::string& value) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  zone_->assign(value);
}
inline void Time::set_zone(const char* value) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  zone_->assign(value);
}
inline void Time::set_zone(const char* value, size_t size) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  zone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Time::mutable_zone() {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  return zone_;
}
inline ::std::string* Time::release_zone() {
  clear_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zone_;
    zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Time::set_allocated_zone(::std::string* zone) {
  if (zone_ != &::google::protobuf::internal::kEmptyString) {
    delete zone_;
  }
  if (zone) {
    set_has_zone();
    zone_ = zone;
  } else {
    clear_has_zone();
    zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string morphosyntactic_features = 9;
inline bool Time::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Time::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Time::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Time::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Time::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Time::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Time::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Time::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Time::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Time::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Time::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 10;
inline bool Time::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Time::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Time::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Time::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Time::preserve_order() const {
  return preserve_order_;
}
inline void Time::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 11;
inline bool Time::has_code_switch() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Time::set_has_code_switch() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Time::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Time::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Time::code_switch() const {
  return *code_switch_;
}
inline void Time::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Time::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Time::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Time::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Time::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Time::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string field_order = 12;
inline int Time::field_order_size() const {
  return field_order_.size();
}
inline void Time::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Time::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Time::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Time::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Time::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Time::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Time::add_field_order() {
  return field_order_.Add();
}
inline void Time::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Time::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Time::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Time::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Time::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Decimal

// optional bool negative = 1;
inline bool Decimal::has_negative() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Decimal::set_has_negative() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Decimal::clear_has_negative() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Decimal::clear_negative() {
  negative_ = false;
  clear_has_negative();
}
inline bool Decimal::negative() const {
  return negative_;
}
inline void Decimal::set_negative(bool value) {
  set_has_negative();
  negative_ = value;
}

// optional string integer_part = 2;
inline bool Decimal::has_integer_part() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Decimal::set_has_integer_part() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Decimal::clear_has_integer_part() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Decimal::clear_integer_part() {
  if (integer_part_ != &::google::protobuf::internal::kEmptyString) {
    integer_part_->clear();
  }
  clear_has_integer_part();
}
inline const ::std::string& Decimal::integer_part() const {
  return *integer_part_;
}
inline void Decimal::set_integer_part(const ::std::string& value) {
  set_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    integer_part_ = new ::std::string;
  }
  integer_part_->assign(value);
}
inline void Decimal::set_integer_part(const char* value) {
  set_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    integer_part_ = new ::std::string;
  }
  integer_part_->assign(value);
}
inline void Decimal::set_integer_part(const char* value, size_t size) {
  set_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    integer_part_ = new ::std::string;
  }
  integer_part_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Decimal::mutable_integer_part() {
  set_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    integer_part_ = new ::std::string;
  }
  return integer_part_;
}
inline ::std::string* Decimal::release_integer_part() {
  clear_has_integer_part();
  if (integer_part_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = integer_part_;
    integer_part_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Decimal::set_allocated_integer_part(::std::string* integer_part) {
  if (integer_part_ != &::google::protobuf::internal::kEmptyString) {
    delete integer_part_;
  }
  if (integer_part) {
    set_has_integer_part();
    integer_part_ = integer_part;
  } else {
    clear_has_integer_part();
    integer_part_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fractional_part = 3;
inline bool Decimal::has_fractional_part() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Decimal::set_has_fractional_part() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Decimal::clear_has_fractional_part() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Decimal::clear_fractional_part() {
  if (fractional_part_ != &::google::protobuf::internal::kEmptyString) {
    fractional_part_->clear();
  }
  clear_has_fractional_part();
}
inline const ::std::string& Decimal::fractional_part() const {
  return *fractional_part_;
}
inline void Decimal::set_fractional_part(const ::std::string& value) {
  set_has_fractional_part();
  if (fractional_part_ == &::google::protobuf::internal::kEmptyString) {
    fractional_part_ = new ::std::string;
  }
  fractional_part_->assign(value);
}
inline void Decimal::set_fractional_part(const char* value) {
  set_has_fractional_part();
  if (fractional_part_ == &::google::protobuf::internal::kEmptyString) {
    fractional_part_ = new ::std::string;
  }
  fractional_part_->assign(value);
}
inline void Decimal::set_fractional_part(const char* value, size_t size) {
  set_has_fractional_part();
  if (fractional_part_ == &::google::protobuf::internal::kEmptyString) {
    fractional_part_ = new ::std::string;
  }
  fractional_part_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Decimal::mutable_fractional_part() {
  set_has_fractional_part();
  if (fractional_part_ == &::google::protobuf::internal::kEmptyString) {
    fractional_part_ = new ::std::string;
  }
  return fractional_part_;
}
inline ::std::string* Decimal::release_fractional_part() {
  clear_has_fractional_part();
  if (fractional_part_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fractional_part_;
    fractional_part_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Decimal::set_allocated_fractional_part(::std::string* fractional_part) {
  if (fractional_part_ != &::google::protobuf::internal::kEmptyString) {
    delete fractional_part_;
  }
  if (fractional_part) {
    set_has_fractional_part();
    fractional_part_ = fractional_part;
  } else {
    clear_has_fractional_part();
    fractional_part_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string quantity = 4;
inline bool Decimal::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Decimal::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Decimal::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Decimal::clear_quantity() {
  if (quantity_ != &::google::protobuf::internal::kEmptyString) {
    quantity_->clear();
  }
  clear_has_quantity();
}
inline const ::std::string& Decimal::quantity() const {
  return *quantity_;
}
inline void Decimal::set_quantity(const ::std::string& value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
}
inline void Decimal::set_quantity(const char* value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
}
inline void Decimal::set_quantity(const char* value, size_t size) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Decimal::mutable_quantity() {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    quantity_ = new ::std::string;
  }
  return quantity_;
}
inline ::std::string* Decimal::release_quantity() {
  clear_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quantity_;
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Decimal::set_allocated_quantity(::std::string* quantity) {
  if (quantity_ != &::google::protobuf::internal::kEmptyString) {
    delete quantity_;
  }
  if (quantity) {
    set_has_quantity();
    quantity_ = quantity;
  } else {
    clear_has_quantity();
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string exponent = 5;
inline bool Decimal::has_exponent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Decimal::set_has_exponent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Decimal::clear_has_exponent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Decimal::clear_exponent() {
  if (exponent_ != &::google::protobuf::internal::kEmptyString) {
    exponent_->clear();
  }
  clear_has_exponent();
}
inline const ::std::string& Decimal::exponent() const {
  return *exponent_;
}
inline void Decimal::set_exponent(const ::std::string& value) {
  set_has_exponent();
  if (exponent_ == &::google::protobuf::internal::kEmptyString) {
    exponent_ = new ::std::string;
  }
  exponent_->assign(value);
}
inline void Decimal::set_exponent(const char* value) {
  set_has_exponent();
  if (exponent_ == &::google::protobuf::internal::kEmptyString) {
    exponent_ = new ::std::string;
  }
  exponent_->assign(value);
}
inline void Decimal::set_exponent(const char* value, size_t size) {
  set_has_exponent();
  if (exponent_ == &::google::protobuf::internal::kEmptyString) {
    exponent_ = new ::std::string;
  }
  exponent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Decimal::mutable_exponent() {
  set_has_exponent();
  if (exponent_ == &::google::protobuf::internal::kEmptyString) {
    exponent_ = new ::std::string;
  }
  return exponent_;
}
inline ::std::string* Decimal::release_exponent() {
  clear_has_exponent();
  if (exponent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exponent_;
    exponent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Decimal::set_allocated_exponent(::std::string* exponent) {
  if (exponent_ != &::google::protobuf::internal::kEmptyString) {
    delete exponent_;
  }
  if (exponent) {
    set_has_exponent();
    exponent_ = exponent;
  } else {
    clear_has_exponent();
    exponent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 style = 6 [deprecated = true];
inline bool Decimal::has_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Decimal::set_has_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Decimal::clear_has_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Decimal::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Decimal::style() const {
  return style_;
}
inline void Decimal::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
}

// optional string morphosyntactic_features = 7;
inline bool Decimal::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Decimal::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Decimal::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Decimal::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Decimal::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Decimal::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Decimal::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Decimal::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Decimal::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Decimal::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Decimal::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 8;
inline bool Decimal::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Decimal::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Decimal::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Decimal::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Decimal::preserve_order() const {
  return preserve_order_;
}
inline void Decimal::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 9;
inline bool Decimal::has_code_switch() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Decimal::set_has_code_switch() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Decimal::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Decimal::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Decimal::code_switch() const {
  return *code_switch_;
}
inline void Decimal::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Decimal::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Decimal::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Decimal::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Decimal::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Decimal::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string field_order = 10;
inline int Decimal::field_order_size() const {
  return field_order_.size();
}
inline void Decimal::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Decimal::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Decimal::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Decimal::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Decimal::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Decimal::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Decimal::add_field_order() {
  return field_order_.Add();
}
inline void Decimal::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Decimal::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Decimal::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Decimal::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Decimal::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Measure

// optional .speech.sparrowhawk.Decimal decimal = 1;
inline bool Measure::has_decimal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Measure::set_has_decimal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Measure::clear_has_decimal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Measure::clear_decimal() {
  if (decimal_ != NULL) decimal_->::speech::sparrowhawk::Decimal::Clear();
  clear_has_decimal();
}
inline const ::speech::sparrowhawk::Decimal& Measure::decimal() const {
  return decimal_ != NULL ? *decimal_ : *default_instance_->decimal_;
}
inline ::speech::sparrowhawk::Decimal* Measure::mutable_decimal() {
  set_has_decimal();
  if (decimal_ == NULL) decimal_ = new ::speech::sparrowhawk::Decimal;
  return decimal_;
}
inline ::speech::sparrowhawk::Decimal* Measure::release_decimal() {
  clear_has_decimal();
  ::speech::sparrowhawk::Decimal* temp = decimal_;
  decimal_ = NULL;
  return temp;
}
inline void Measure::set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal) {
  delete decimal_;
  decimal_ = decimal;
  if (decimal) {
    set_has_decimal();
  } else {
    clear_has_decimal();
  }
}

// optional .speech.sparrowhawk.Fraction fraction = 2;
inline bool Measure::has_fraction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Measure::set_has_fraction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Measure::clear_has_fraction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Measure::clear_fraction() {
  if (fraction_ != NULL) fraction_->::speech::sparrowhawk::Fraction::Clear();
  clear_has_fraction();
}
inline const ::speech::sparrowhawk::Fraction& Measure::fraction() const {
  return fraction_ != NULL ? *fraction_ : *default_instance_->fraction_;
}
inline ::speech::sparrowhawk::Fraction* Measure::mutable_fraction() {
  set_has_fraction();
  if (fraction_ == NULL) fraction_ = new ::speech::sparrowhawk::Fraction;
  return fraction_;
}
inline ::speech::sparrowhawk::Fraction* Measure::release_fraction() {
  clear_has_fraction();
  ::speech::sparrowhawk::Fraction* temp = fraction_;
  fraction_ = NULL;
  return temp;
}
inline void Measure::set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction) {
  delete fraction_;
  fraction_ = fraction;
  if (fraction) {
    set_has_fraction();
  } else {
    clear_has_fraction();
  }
}

// optional .speech.sparrowhawk.Cardinal cardinal = 3;
inline bool Measure::has_cardinal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Measure::set_has_cardinal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Measure::clear_has_cardinal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Measure::clear_cardinal() {
  if (cardinal_ != NULL) cardinal_->::speech::sparrowhawk::Cardinal::Clear();
  clear_has_cardinal();
}
inline const ::speech::sparrowhawk::Cardinal& Measure::cardinal() const {
  return cardinal_ != NULL ? *cardinal_ : *default_instance_->cardinal_;
}
inline ::speech::sparrowhawk::Cardinal* Measure::mutable_cardinal() {
  set_has_cardinal();
  if (cardinal_ == NULL) cardinal_ = new ::speech::sparrowhawk::Cardinal;
  return cardinal_;
}
inline ::speech::sparrowhawk::Cardinal* Measure::release_cardinal() {
  clear_has_cardinal();
  ::speech::sparrowhawk::Cardinal* temp = cardinal_;
  cardinal_ = NULL;
  return temp;
}
inline void Measure::set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal) {
  delete cardinal_;
  cardinal_ = cardinal;
  if (cardinal) {
    set_has_cardinal();
  } else {
    clear_has_cardinal();
  }
}

// optional string units = 4;
inline bool Measure::has_units() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Measure::set_has_units() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Measure::clear_has_units() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Measure::clear_units() {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    units_->clear();
  }
  clear_has_units();
}
inline const ::std::string& Measure::units() const {
  return *units_;
}
inline void Measure::set_units(const ::std::string& value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void Measure::set_units(const char* value) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(value);
}
inline void Measure::set_units(const char* value, size_t size) {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  units_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Measure::mutable_units() {
  set_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    units_ = new ::std::string;
  }
  return units_;
}
inline ::std::string* Measure::release_units() {
  clear_has_units();
  if (units_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = units_;
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Measure::set_allocated_units(::std::string* units) {
  if (units_ != &::google::protobuf::internal::kEmptyString) {
    delete units_;
  }
  if (units) {
    set_has_units();
    units_ = units;
  } else {
    clear_has_units();
    units_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 style = 5 [deprecated = true];
inline bool Measure::has_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Measure::set_has_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Measure::clear_has_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Measure::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Measure::style() const {
  return style_;
}
inline void Measure::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
}

// optional string morphosyntactic_features = 6;
inline bool Measure::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Measure::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Measure::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Measure::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Measure::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Measure::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Measure::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Measure::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Measure::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Measure::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Measure::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 7;
inline bool Measure::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Measure::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Measure::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Measure::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Measure::preserve_order() const {
  return preserve_order_;
}
inline void Measure::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 8;
inline bool Measure::has_code_switch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Measure::set_has_code_switch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Measure::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Measure::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Measure::code_switch() const {
  return *code_switch_;
}
inline void Measure::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Measure::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Measure::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Measure::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Measure::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Measure::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string field_order = 9;
inline int Measure::field_order_size() const {
  return field_order_.size();
}
inline void Measure::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Measure::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Measure::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Measure::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Measure::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Measure::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Measure::add_field_order() {
  return field_order_.Add();
}
inline void Measure::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Measure::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Measure::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Measure::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Measure::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Date

// optional string weekday = 1;
inline bool Date::has_weekday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Date::set_has_weekday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Date::clear_has_weekday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Date::clear_weekday() {
  if (weekday_ != &::google::protobuf::internal::kEmptyString) {
    weekday_->clear();
  }
  clear_has_weekday();
}
inline const ::std::string& Date::weekday() const {
  return *weekday_;
}
inline void Date::set_weekday(const ::std::string& value) {
  set_has_weekday();
  if (weekday_ == &::google::protobuf::internal::kEmptyString) {
    weekday_ = new ::std::string;
  }
  weekday_->assign(value);
}
inline void Date::set_weekday(const char* value) {
  set_has_weekday();
  if (weekday_ == &::google::protobuf::internal::kEmptyString) {
    weekday_ = new ::std::string;
  }
  weekday_->assign(value);
}
inline void Date::set_weekday(const char* value, size_t size) {
  set_has_weekday();
  if (weekday_ == &::google::protobuf::internal::kEmptyString) {
    weekday_ = new ::std::string;
  }
  weekday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Date::mutable_weekday() {
  set_has_weekday();
  if (weekday_ == &::google::protobuf::internal::kEmptyString) {
    weekday_ = new ::std::string;
  }
  return weekday_;
}
inline ::std::string* Date::release_weekday() {
  clear_has_weekday();
  if (weekday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weekday_;
    weekday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Date::set_allocated_weekday(::std::string* weekday) {
  if (weekday_ != &::google::protobuf::internal::kEmptyString) {
    delete weekday_;
  }
  if (weekday) {
    set_has_weekday();
    weekday_ = weekday;
  } else {
    clear_has_weekday();
    weekday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string day = 2;
inline bool Date::has_day() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Date::set_has_day() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Date::clear_has_day() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Date::clear_day() {
  if (day_ != &::google::protobuf::internal::kEmptyString) {
    day_->clear();
  }
  clear_has_day();
}
inline const ::std::string& Date::day() const {
  return *day_;
}
inline void Date::set_day(const ::std::string& value) {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  day_->assign(value);
}
inline void Date::set_day(const char* value) {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  day_->assign(value);
}
inline void Date::set_day(const char* value, size_t size) {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  day_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Date::mutable_day() {
  set_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    day_ = new ::std::string;
  }
  return day_;
}
inline ::std::string* Date::release_day() {
  clear_has_day();
  if (day_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = day_;
    day_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Date::set_allocated_day(::std::string* day) {
  if (day_ != &::google::protobuf::internal::kEmptyString) {
    delete day_;
  }
  if (day) {
    set_has_day();
    day_ = day;
  } else {
    clear_has_day();
    day_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string month = 3;
inline bool Date::has_month() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Date::set_has_month() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Date::clear_has_month() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Date::clear_month() {
  if (month_ != &::google::protobuf::internal::kEmptyString) {
    month_->clear();
  }
  clear_has_month();
}
inline const ::std::string& Date::month() const {
  return *month_;
}
inline void Date::set_month(const ::std::string& value) {
  set_has_month();
  if (month_ == &::google::protobuf::internal::kEmptyString) {
    month_ = new ::std::string;
  }
  month_->assign(value);
}
inline void Date::set_month(const char* value) {
  set_has_month();
  if (month_ == &::google::protobuf::internal::kEmptyString) {
    month_ = new ::std::string;
  }
  month_->assign(value);
}
inline void Date::set_month(const char* value, size_t size) {
  set_has_month();
  if (month_ == &::google::protobuf::internal::kEmptyString) {
    month_ = new ::std::string;
  }
  month_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Date::mutable_month() {
  set_has_month();
  if (month_ == &::google::protobuf::internal::kEmptyString) {
    month_ = new ::std::string;
  }
  return month_;
}
inline ::std::string* Date::release_month() {
  clear_has_month();
  if (month_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = month_;
    month_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Date::set_allocated_month(::std::string* month) {
  if (month_ != &::google::protobuf::internal::kEmptyString) {
    delete month_;
  }
  if (month) {
    set_has_month();
    month_ = month;
  } else {
    clear_has_month();
    month_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string year = 4;
inline bool Date::has_year() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Date::set_has_year() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Date::clear_has_year() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Date::clear_year() {
  if (year_ != &::google::protobuf::internal::kEmptyString) {
    year_->clear();
  }
  clear_has_year();
}
inline const ::std::string& Date::year() const {
  return *year_;
}
inline void Date::set_year(const ::std::string& value) {
  set_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    year_ = new ::std::string;
  }
  year_->assign(value);
}
inline void Date::set_year(const char* value) {
  set_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    year_ = new ::std::string;
  }
  year_->assign(value);
}
inline void Date::set_year(const char* value, size_t size) {
  set_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    year_ = new ::std::string;
  }
  year_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Date::mutable_year() {
  set_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    year_ = new ::std::string;
  }
  return year_;
}
inline ::std::string* Date::release_year() {
  clear_has_year();
  if (year_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = year_;
    year_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Date::set_allocated_year(::std::string* year) {
  if (year_ != &::google::protobuf::internal::kEmptyString) {
    delete year_;
  }
  if (year) {
    set_has_year();
    year_ = year;
  } else {
    clear_has_year();
    year_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 style = 5 [deprecated = true];
inline bool Date::has_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Date::set_has_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Date::clear_has_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Date::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Date::style() const {
  return style_;
}
inline void Date::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
}

// optional string text = 6 [deprecated = true];
inline bool Date::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Date::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Date::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Date::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Date::text() const {
  return *text_;
}
inline void Date::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Date::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Date::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Date::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Date::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Date::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool short_year = 7 [deprecated = true];
inline bool Date::has_short_year() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Date::set_has_short_year() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Date::clear_has_short_year() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Date::clear_short_year() {
  short_year_ = false;
  clear_has_short_year();
}
inline bool Date::short_year() const {
  return short_year_;
}
inline void Date::set_short_year(bool value) {
  set_has_short_year();
  short_year_ = value;
}

// optional string era = 8;
inline bool Date::has_era() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Date::set_has_era() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Date::clear_has_era() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Date::clear_era() {
  if (era_ != &::google::protobuf::internal::kEmptyString) {
    era_->clear();
  }
  clear_has_era();
}
inline const ::std::string& Date::era() const {
  return *era_;
}
inline void Date::set_era(const ::std::string& value) {
  set_has_era();
  if (era_ == &::google::protobuf::internal::kEmptyString) {
    era_ = new ::std::string;
  }
  era_->assign(value);
}
inline void Date::set_era(const char* value) {
  set_has_era();
  if (era_ == &::google::protobuf::internal::kEmptyString) {
    era_ = new ::std::string;
  }
  era_->assign(value);
}
inline void Date::set_era(const char* value, size_t size) {
  set_has_era();
  if (era_ == &::google::protobuf::internal::kEmptyString) {
    era_ = new ::std::string;
  }
  era_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Date::mutable_era() {
  set_has_era();
  if (era_ == &::google::protobuf::internal::kEmptyString) {
    era_ = new ::std::string;
  }
  return era_;
}
inline ::std::string* Date::release_era() {
  clear_has_era();
  if (era_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = era_;
    era_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Date::set_allocated_era(::std::string* era) {
  if (era_ != &::google::protobuf::internal::kEmptyString) {
    delete era_;
  }
  if (era) {
    set_has_era();
    era_ = era;
  } else {
    clear_has_era();
    era_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string morphosyntactic_features = 9;
inline bool Date::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Date::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Date::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Date::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Date::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Date::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Date::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Date::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Date::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Date::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Date::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 10;
inline bool Date::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Date::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Date::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Date::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Date::preserve_order() const {
  return preserve_order_;
}
inline void Date::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 11;
inline bool Date::has_code_switch() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Date::set_has_code_switch() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Date::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Date::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Date::code_switch() const {
  return *code_switch_;
}
inline void Date::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Date::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Date::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Date::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Date::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Date::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string field_order = 12;
inline int Date::field_order_size() const {
  return field_order_.size();
}
inline void Date::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Date::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Date::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Date::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Date::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Date::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Date::add_field_order() {
  return field_order_.Add();
}
inline void Date::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Date::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Date::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Date::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Date::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Money

// required .speech.sparrowhawk.Decimal amount = 1;
inline bool Money::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Money::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Money::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Money::clear_amount() {
  if (amount_ != NULL) amount_->::speech::sparrowhawk::Decimal::Clear();
  clear_has_amount();
}
inline const ::speech::sparrowhawk::Decimal& Money::amount() const {
  return amount_ != NULL ? *amount_ : *default_instance_->amount_;
}
inline ::speech::sparrowhawk::Decimal* Money::mutable_amount() {
  set_has_amount();
  if (amount_ == NULL) amount_ = new ::speech::sparrowhawk::Decimal;
  return amount_;
}
inline ::speech::sparrowhawk::Decimal* Money::release_amount() {
  clear_has_amount();
  ::speech::sparrowhawk::Decimal* temp = amount_;
  amount_ = NULL;
  return temp;
}
inline void Money::set_allocated_amount(::speech::sparrowhawk::Decimal* amount) {
  delete amount_;
  amount_ = amount;
  if (amount) {
    set_has_amount();
  } else {
    clear_has_amount();
  }
}

// optional int64 quantity = 2;
inline bool Money::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Money::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Money::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Money::clear_quantity() {
  quantity_ = GOOGLE_LONGLONG(0);
  clear_has_quantity();
}
inline ::google::protobuf::int64 Money::quantity() const {
  return quantity_;
}
inline void Money::set_quantity(::google::protobuf::int64 value) {
  set_has_quantity();
  quantity_ = value;
}

// required string currency = 3;
inline bool Money::has_currency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Money::set_has_currency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Money::clear_has_currency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Money::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& Money::currency() const {
  return *currency_;
}
inline void Money::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void Money::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void Money::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Money::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* Money::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Money::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 style = 4 [deprecated = true];
inline bool Money::has_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Money::set_has_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Money::clear_has_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Money::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Money::style() const {
  return style_;
}
inline void Money::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
}

// optional string morphosyntactic_features = 5;
inline bool Money::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Money::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Money::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Money::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Money::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Money::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Money::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Money::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Money::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Money::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Money::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 6;
inline bool Money::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Money::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Money::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Money::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Money::preserve_order() const {
  return preserve_order_;
}
inline void Money::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 7;
inline bool Money::has_code_switch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Money::set_has_code_switch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Money::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Money::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Money::code_switch() const {
  return *code_switch_;
}
inline void Money::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Money::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Money::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Money::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Money::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Money::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string field_order = 8;
inline int Money::field_order_size() const {
  return field_order_.size();
}
inline void Money::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Money::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Money::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Money::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Money::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Money::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Money::add_field_order() {
  return field_order_.Add();
}
inline void Money::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Money::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Money::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Money::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Money::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Telephone

// optional string country_code = 1;
inline bool Telephone::has_country_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telephone::set_has_country_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telephone::clear_has_country_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telephone::clear_country_code() {
  if (country_code_ != &::google::protobuf::internal::kEmptyString) {
    country_code_->clear();
  }
  clear_has_country_code();
}
inline const ::std::string& Telephone::country_code() const {
  return *country_code_;
}
inline void Telephone::set_country_code(const ::std::string& value) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(value);
}
inline void Telephone::set_country_code(const char* value) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(value);
}
inline void Telephone::set_country_code(const char* value, size_t size) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Telephone::mutable_country_code() {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  return country_code_;
}
inline ::std::string* Telephone::release_country_code() {
  clear_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_code_;
    country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Telephone::set_allocated_country_code(::std::string* country_code) {
  if (country_code_ != &::google::protobuf::internal::kEmptyString) {
    delete country_code_;
  }
  if (country_code) {
    set_has_country_code();
    country_code_ = country_code;
  } else {
    clear_has_country_code();
    country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string number_part = 2;
inline int Telephone::number_part_size() const {
  return number_part_.size();
}
inline void Telephone::clear_number_part() {
  number_part_.Clear();
}
inline const ::std::string& Telephone::number_part(int index) const {
  return number_part_.Get(index);
}
inline ::std::string* Telephone::mutable_number_part(int index) {
  return number_part_.Mutable(index);
}
inline void Telephone::set_number_part(int index, const ::std::string& value) {
  number_part_.Mutable(index)->assign(value);
}
inline void Telephone::set_number_part(int index, const char* value) {
  number_part_.Mutable(index)->assign(value);
}
inline void Telephone::set_number_part(int index, const char* value, size_t size) {
  number_part_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Telephone::add_number_part() {
  return number_part_.Add();
}
inline void Telephone::add_number_part(const ::std::string& value) {
  number_part_.Add()->assign(value);
}
inline void Telephone::add_number_part(const char* value) {
  number_part_.Add()->assign(value);
}
inline void Telephone::add_number_part(const char* value, size_t size) {
  number_part_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Telephone::number_part() const {
  return number_part_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Telephone::mutable_number_part() {
  return &number_part_;
}

// optional string extension = 3;
inline bool Telephone::has_extension() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telephone::set_has_extension() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telephone::clear_has_extension() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telephone::clear_extension() {
  if (extension_ != &::google::protobuf::internal::kEmptyString) {
    extension_->clear();
  }
  clear_has_extension();
}
inline const ::std::string& Telephone::extension() const {
  return *extension_;
}
inline void Telephone::set_extension(const ::std::string& value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
}
inline void Telephone::set_extension(const char* value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
}
inline void Telephone::set_extension(const char* value, size_t size) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  extension_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Telephone::mutable_extension() {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    extension_ = new ::std::string;
  }
  return extension_;
}
inline ::std::string* Telephone::release_extension() {
  clear_has_extension();
  if (extension_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extension_;
    extension_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Telephone::set_allocated_extension(::std::string* extension) {
  if (extension_ != &::google::protobuf::internal::kEmptyString) {
    delete extension_;
  }
  if (extension) {
    set_has_extension();
    extension_ = extension;
  } else {
    clear_has_extension();
    extension_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 style = 4 [deprecated = true];
inline bool Telephone::has_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telephone::set_has_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telephone::clear_has_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telephone::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Telephone::style() const {
  return style_;
}
inline void Telephone::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
}

// optional string morphosyntactic_features = 5;
inline bool Telephone::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telephone::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telephone::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telephone::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Telephone::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Telephone::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Telephone::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Telephone::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Telephone::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Telephone::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Telephone::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 6;
inline bool Telephone::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Telephone::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Telephone::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Telephone::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Telephone::preserve_order() const {
  return preserve_order_;
}
inline void Telephone::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 7;
inline bool Telephone::has_code_switch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Telephone::set_has_code_switch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Telephone::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Telephone::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Telephone::code_switch() const {
  return *code_switch_;
}
inline void Telephone::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Telephone::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Telephone::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Telephone::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Telephone::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Telephone::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string field_order = 8;
inline int Telephone::field_order_size() const {
  return field_order_.size();
}
inline void Telephone::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Telephone::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Telephone::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Telephone::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Telephone::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Telephone::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Telephone::add_field_order() {
  return field_order_.Add();
}
inline void Telephone::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Telephone::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Telephone::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Telephone::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Telephone::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Electronic

// optional string protocol = 1;
inline bool Electronic::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Electronic::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Electronic::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Electronic::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& Electronic::protocol() const {
  return *protocol_;
}
inline void Electronic::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void Electronic::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void Electronic::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}
inline ::std::string* Electronic::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Electronic::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username = 2;
inline bool Electronic::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Electronic::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Electronic::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Electronic::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Electronic::username() const {
  return *username_;
}
inline void Electronic::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Electronic::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Electronic::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Electronic::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Electronic::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 3;
inline bool Electronic::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Electronic::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Electronic::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Electronic::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Electronic::password() const {
  return *password_;
}
inline void Electronic::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Electronic::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Electronic::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Electronic::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Electronic::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain = 4;
inline bool Electronic::has_domain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Electronic::set_has_domain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Electronic::clear_has_domain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Electronic::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& Electronic::domain() const {
  return *domain_;
}
inline void Electronic::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void Electronic::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void Electronic::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* Electronic::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Electronic::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 5;
inline bool Electronic::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Electronic::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Electronic::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Electronic::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Electronic::port() const {
  return port_;
}
inline void Electronic::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional string path = 6;
inline bool Electronic::has_path() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Electronic::set_has_path() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Electronic::clear_has_path() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Electronic::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Electronic::path() const {
  return *path_;
}
inline void Electronic::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Electronic::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Electronic::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* Electronic::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Electronic::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string query_string = 7;
inline bool Electronic::has_query_string() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Electronic::set_has_query_string() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Electronic::clear_has_query_string() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Electronic::clear_query_string() {
  if (query_string_ != &::google::protobuf::internal::kEmptyString) {
    query_string_->clear();
  }
  clear_has_query_string();
}
inline const ::std::string& Electronic::query_string() const {
  return *query_string_;
}
inline void Electronic::set_query_string(const ::std::string& value) {
  set_has_query_string();
  if (query_string_ == &::google::protobuf::internal::kEmptyString) {
    query_string_ = new ::std::string;
  }
  query_string_->assign(value);
}
inline void Electronic::set_query_string(const char* value) {
  set_has_query_string();
  if (query_string_ == &::google::protobuf::internal::kEmptyString) {
    query_string_ = new ::std::string;
  }
  query_string_->assign(value);
}
inline void Electronic::set_query_string(const char* value, size_t size) {
  set_has_query_string();
  if (query_string_ == &::google::protobuf::internal::kEmptyString) {
    query_string_ = new ::std::string;
  }
  query_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::mutable_query_string() {
  set_has_query_string();
  if (query_string_ == &::google::protobuf::internal::kEmptyString) {
    query_string_ = new ::std::string;
  }
  return query_string_;
}
inline ::std::string* Electronic::release_query_string() {
  clear_has_query_string();
  if (query_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_string_;
    query_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Electronic::set_allocated_query_string(::std::string* query_string) {
  if (query_string_ != &::google::protobuf::internal::kEmptyString) {
    delete query_string_;
  }
  if (query_string) {
    set_has_query_string();
    query_string_ = query_string;
  } else {
    clear_has_query_string();
    query_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fragment_id = 8;
inline bool Electronic::has_fragment_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Electronic::set_has_fragment_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Electronic::clear_has_fragment_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Electronic::clear_fragment_id() {
  if (fragment_id_ != &::google::protobuf::internal::kEmptyString) {
    fragment_id_->clear();
  }
  clear_has_fragment_id();
}
inline const ::std::string& Electronic::fragment_id() const {
  return *fragment_id_;
}
inline void Electronic::set_fragment_id(const ::std::string& value) {
  set_has_fragment_id();
  if (fragment_id_ == &::google::protobuf::internal::kEmptyString) {
    fragment_id_ = new ::std::string;
  }
  fragment_id_->assign(value);
}
inline void Electronic::set_fragment_id(const char* value) {
  set_has_fragment_id();
  if (fragment_id_ == &::google::protobuf::internal::kEmptyString) {
    fragment_id_ = new ::std::string;
  }
  fragment_id_->assign(value);
}
inline void Electronic::set_fragment_id(const char* value, size_t size) {
  set_has_fragment_id();
  if (fragment_id_ == &::google::protobuf::internal::kEmptyString) {
    fragment_id_ = new ::std::string;
  }
  fragment_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::mutable_fragment_id() {
  set_has_fragment_id();
  if (fragment_id_ == &::google::protobuf::internal::kEmptyString) {
    fragment_id_ = new ::std::string;
  }
  return fragment_id_;
}
inline ::std::string* Electronic::release_fragment_id() {
  clear_has_fragment_id();
  if (fragment_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fragment_id_;
    fragment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Electronic::set_allocated_fragment_id(::std::string* fragment_id) {
  if (fragment_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fragment_id_;
  }
  if (fragment_id) {
    set_has_fragment_id();
    fragment_id_ = fragment_id;
  } else {
    clear_has_fragment_id();
    fragment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string morphosyntactic_features = 9;
inline bool Electronic::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Electronic::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Electronic::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Electronic::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Electronic::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Electronic::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Electronic::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Electronic::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Electronic::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Electronic::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool preserve_order = 10;
inline bool Electronic::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Electronic::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Electronic::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Electronic::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Electronic::preserve_order() const {
  return preserve_order_;
}
inline void Electronic::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
}

// optional string code_switch = 11;
inline bool Electronic::has_code_switch() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Electronic::set_has_code_switch() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Electronic::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Electronic::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Electronic::code_switch() const {
  return *code_switch_;
}
inline void Electronic::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Electronic::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Electronic::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Electronic::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Electronic::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string field_order = 12;
inline int Electronic::field_order_size() const {
  return field_order_.size();
}
inline void Electronic::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Electronic::field_order(int index) const {
  return field_order_.Get(index);
}
inline ::std::string* Electronic::mutable_field_order(int index) {
  return field_order_.Mutable(index);
}
inline void Electronic::set_field_order(int index, const ::std::string& value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Electronic::set_field_order(int index, const char* value) {
  field_order_.Mutable(index)->assign(value);
}
inline void Electronic::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Electronic::add_field_order() {
  return field_order_.Add();
}
inline void Electronic::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
}
inline void Electronic::add_field_order(const char* value) {
  field_order_.Add()->assign(value);
}
inline void Electronic::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Electronic::field_order() const {
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Electronic::mutable_field_order() {
  return &field_order_;
}

// -------------------------------------------------------------------

// Connector

// optional string type = 1;
inline bool Connector::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connector::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connector::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connector::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Connector::type() const {
  return *type_;
}
inline void Connector::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Connector::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Connector::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connector::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* Connector::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connector::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string morphosyntactic_features = 2;
inline bool Connector::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Connector::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Connector::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Connector::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Connector::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Connector::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Connector::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Connector::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connector::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Connector::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connector::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string code_switch = 3;
inline bool Connector::has_code_switch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Connector::set_has_code_switch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Connector::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Connector::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Connector::code_switch() const {
  return *code_switch_;
}
inline void Connector::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Connector::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Connector::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Connector::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Connector::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Connector::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Abbreviation

// required string text = 1;
inline bool Abbreviation::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Abbreviation::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Abbreviation::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Abbreviation::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Abbreviation::text() const {
  return *text_;
}
inline void Abbreviation::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Abbreviation::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Abbreviation::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Abbreviation::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Abbreviation::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Abbreviation::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string morphosyntactic_features = 2;
inline bool Abbreviation::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Abbreviation::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Abbreviation::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Abbreviation::clear_morphosyntactic_features() {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_->clear();
  }
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Abbreviation::morphosyntactic_features() const {
  return *morphosyntactic_features_;
}
inline void Abbreviation::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Abbreviation::set_morphosyntactic_features(const char* value) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(value);
}
inline void Abbreviation::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  morphosyntactic_features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Abbreviation::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    morphosyntactic_features_ = new ::std::string;
  }
  return morphosyntactic_features_;
}
inline ::std::string* Abbreviation::release_morphosyntactic_features() {
  clear_has_morphosyntactic_features();
  if (morphosyntactic_features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = morphosyntactic_features_;
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Abbreviation::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features_ != &::google::protobuf::internal::kEmptyString) {
    delete morphosyntactic_features_;
  }
  if (morphosyntactic_features) {
    set_has_morphosyntactic_features();
    morphosyntactic_features_ = morphosyntactic_features;
  } else {
    clear_has_morphosyntactic_features();
    morphosyntactic_features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string code_switch = 3;
inline bool Abbreviation::has_code_switch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Abbreviation::set_has_code_switch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Abbreviation::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Abbreviation::clear_code_switch() {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    code_switch_->clear();
  }
  clear_has_code_switch();
}
inline const ::std::string& Abbreviation::code_switch() const {
  return *code_switch_;
}
inline void Abbreviation::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Abbreviation::set_code_switch(const char* value) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(value);
}
inline void Abbreviation::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  code_switch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Abbreviation::mutable_code_switch() {
  set_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    code_switch_ = new ::std::string;
  }
  return code_switch_;
}
inline ::std::string* Abbreviation::release_code_switch() {
  clear_has_code_switch();
  if (code_switch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_switch_;
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Abbreviation::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch_ != &::google::protobuf::internal::kEmptyString) {
    delete code_switch_;
  }
  if (code_switch) {
    set_has_code_switch();
    code_switch_ = code_switch;
  } else {
    clear_has_code_switch();
    code_switch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sparrowhawk
}  // namespace speech

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_semiotic_5fclasses_2eproto__INCLUDED
