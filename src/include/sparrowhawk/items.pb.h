// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: items.proto

#ifndef PROTOBUF_items_2eproto__INCLUDED
#define PROTOBUF_items_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "links.pb.h"
#include "semiotic_classes.pb.h"
// @@protoc_insertion_point(includes)

namespace speech {
namespace sparrowhawk {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_items_2eproto();
void protobuf_AssignDesc_items_2eproto();
void protobuf_ShutdownFile_items_2eproto();

class Token;
class Word;
class LinguisticStructure;
class Utterance;

enum Token_Type {
  Token_Type_WORD = 1,
  Token_Type_SEMIOTIC_CLASS = 2,
  Token_Type_PUNCT = 3,
  Token_Type_WORD_NEEDS_VERBALIZATION = 4
};
bool Token_Type_IsValid(int value);
const Token_Type Token_Type_Type_MIN = Token_Type_WORD;
const Token_Type Token_Type_Type_MAX = Token_Type_WORD_NEEDS_VERBALIZATION;
const int Token_Type_Type_ARRAYSIZE = Token_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Token_Type_descriptor();
inline const ::std::string& Token_Type_Name(Token_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Token_Type_descriptor(), value);
}
inline bool Token_Type_Parse(
    const ::std::string& name, Token_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Token_Type>(
    Token_Type_descriptor(), name, value);
}
enum Token_PauseLength {
  Token_PauseLength_PAUSE_NONE = 0,
  Token_PauseLength_PAUSE_SHORT = 1,
  Token_PauseLength_PAUSE_MEDIUM = 2,
  Token_PauseLength_PAUSE_LONG = 3
};
bool Token_PauseLength_IsValid(int value);
const Token_PauseLength Token_PauseLength_PauseLength_MIN = Token_PauseLength_PAUSE_NONE;
const Token_PauseLength Token_PauseLength_PauseLength_MAX = Token_PauseLength_PAUSE_LONG;
const int Token_PauseLength_PauseLength_ARRAYSIZE = Token_PauseLength_PauseLength_MAX + 1;

const ::google::protobuf::EnumDescriptor* Token_PauseLength_descriptor();
inline const ::std::string& Token_PauseLength_Name(Token_PauseLength value) {
  return ::google::protobuf::internal::NameOfEnum(
    Token_PauseLength_descriptor(), value);
}
inline bool Token_PauseLength_Parse(
    const ::std::string& name, Token_PauseLength* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Token_PauseLength>(
    Token_PauseLength_descriptor(), name, value);
}
// ===================================================================

class Token : public ::google::protobuf::Message {
 public:
  Token();
  virtual ~Token();

  Token(const Token& from);

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Token& default_instance();

  void Swap(Token* other);

  // implements Message ----------------------------------------------

  Token* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Token_Type Type;
  static const Type WORD = Token_Type_WORD;
  static const Type SEMIOTIC_CLASS = Token_Type_SEMIOTIC_CLASS;
  static const Type PUNCT = Token_Type_PUNCT;
  static const Type WORD_NEEDS_VERBALIZATION = Token_Type_WORD_NEEDS_VERBALIZATION;
  static inline bool Type_IsValid(int value) {
    return Token_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Token_Type_Type_MIN;
  static const Type Type_MAX =
    Token_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Token_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Token_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Token_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Token_Type_Parse(name, value);
  }

  typedef Token_PauseLength PauseLength;
  static const PauseLength PAUSE_NONE = Token_PauseLength_PAUSE_NONE;
  static const PauseLength PAUSE_SHORT = Token_PauseLength_PAUSE_SHORT;
  static const PauseLength PAUSE_MEDIUM = Token_PauseLength_PAUSE_MEDIUM;
  static const PauseLength PAUSE_LONG = Token_PauseLength_PAUSE_LONG;
  static inline bool PauseLength_IsValid(int value) {
    return Token_PauseLength_IsValid(value);
  }
  static const PauseLength PauseLength_MIN =
    Token_PauseLength_PauseLength_MIN;
  static const PauseLength PauseLength_MAX =
    Token_PauseLength_PauseLength_MAX;
  static const int PauseLength_ARRAYSIZE =
    Token_PauseLength_PauseLength_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PauseLength_descriptor() {
    return Token_PauseLength_descriptor();
  }
  static inline const ::std::string& PauseLength_Name(PauseLength value) {
    return Token_PauseLength_Name(value);
  }
  static inline bool PauseLength_Parse(const ::std::string& name,
      PauseLength* value) {
    return Token_PauseLength_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .speech.sparrowhawk.Links links = 1;
  inline bool has_links() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 1;
  inline const ::speech::sparrowhawk::Links& links() const;
  inline ::speech::sparrowhawk::Links* mutable_links();
  inline ::speech::sparrowhawk::Links* release_links();
  inline void set_allocated_links(::speech::sparrowhawk::Links* links);

  // optional uint32 start_index = 2;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // optional uint32 end_index = 3;
  inline bool has_end_index() const;
  inline void clear_end_index();
  static const int kEndIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 end_index() const;
  inline void set_end_index(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .speech.sparrowhawk.Token.Type type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::speech::sparrowhawk::Token_Type type() const;
  inline void set_type(::speech::sparrowhawk::Token_Type value);

  // optional string wordid = 6;
  inline bool has_wordid() const;
  inline void clear_wordid();
  static const int kWordidFieldNumber = 6;
  inline const ::std::string& wordid() const;
  inline void set_wordid(const ::std::string& value);
  inline void set_wordid(const char* value);
  inline void set_wordid(const char* value, size_t size);
  inline ::std::string* mutable_wordid();
  inline ::std::string* release_wordid();
  inline void set_allocated_wordid(::std::string* wordid);

  // optional string spelling = 7;
  inline bool has_spelling() const;
  inline void clear_spelling();
  static const int kSpellingFieldNumber = 7;
  inline const ::std::string& spelling() const;
  inline void set_spelling(const ::std::string& value);
  inline void set_spelling(const char* value);
  inline void set_spelling(const char* value, size_t size);
  inline ::std::string* mutable_spelling();
  inline ::std::string* release_spelling();
  inline void set_allocated_spelling(::std::string* spelling);

  // optional bool phrase_break = 8;
  inline bool has_phrase_break() const;
  inline void clear_phrase_break();
  static const int kPhraseBreakFieldNumber = 8;
  inline bool phrase_break() const;
  inline void set_phrase_break(bool value);

  // optional float pause_duration = 9;
  inline bool has_pause_duration() const;
  inline void clear_pause_duration();
  static const int kPauseDurationFieldNumber = 9;
  inline float pause_duration() const;
  inline void set_pause_duration(float value);

  // optional .speech.sparrowhawk.Token.PauseLength pause_length = 10 [default = PAUSE_NONE];
  inline bool has_pause_length() const;
  inline void clear_pause_length();
  static const int kPauseLengthFieldNumber = 10;
  inline ::speech::sparrowhawk::Token_PauseLength pause_length() const;
  inline void set_pause_length(::speech::sparrowhawk::Token_PauseLength value);

  // optional string spelling_with_stress = 11;
  inline bool has_spelling_with_stress() const;
  inline void clear_spelling_with_stress();
  static const int kSpellingWithStressFieldNumber = 11;
  inline const ::std::string& spelling_with_stress() const;
  inline void set_spelling_with_stress(const ::std::string& value);
  inline void set_spelling_with_stress(const char* value);
  inline void set_spelling_with_stress(const char* value, size_t size);
  inline ::std::string* mutable_spelling_with_stress();
  inline ::std::string* release_spelling_with_stress();
  inline void set_allocated_spelling_with_stress(::std::string* spelling_with_stress);

  // optional bool skip = 12;
  inline bool has_skip() const;
  inline void clear_skip();
  static const int kSkipFieldNumber = 12;
  inline bool skip() const;
  inline void set_skip(bool value);

  // optional bool next_space = 13;
  inline bool has_next_space() const;
  inline void clear_next_space();
  static const int kNextSpaceFieldNumber = 13;
  inline bool next_space() const;
  inline void set_next_space(bool value);

  // optional .speech.sparrowhawk.Cardinal cardinal = 14;
  inline bool has_cardinal() const;
  inline void clear_cardinal();
  static const int kCardinalFieldNumber = 14;
  inline const ::speech::sparrowhawk::Cardinal& cardinal() const;
  inline ::speech::sparrowhawk::Cardinal* mutable_cardinal();
  inline ::speech::sparrowhawk::Cardinal* release_cardinal();
  inline void set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal);

  // optional .speech.sparrowhawk.Ordinal ordinal = 15;
  inline bool has_ordinal() const;
  inline void clear_ordinal();
  static const int kOrdinalFieldNumber = 15;
  inline const ::speech::sparrowhawk::Ordinal& ordinal() const;
  inline ::speech::sparrowhawk::Ordinal* mutable_ordinal();
  inline ::speech::sparrowhawk::Ordinal* release_ordinal();
  inline void set_allocated_ordinal(::speech::sparrowhawk::Ordinal* ordinal);

  // optional string digit = 16;
  inline bool has_digit() const;
  inline void clear_digit();
  static const int kDigitFieldNumber = 16;
  inline const ::std::string& digit() const;
  inline void set_digit(const ::std::string& value);
  inline void set_digit(const char* value);
  inline void set_digit(const char* value, size_t size);
  inline ::std::string* mutable_digit();
  inline ::std::string* release_digit();
  inline void set_allocated_digit(::std::string* digit);

  // optional .speech.sparrowhawk.Decimal decimal = 17;
  inline bool has_decimal() const;
  inline void clear_decimal();
  static const int kDecimalFieldNumber = 17;
  inline const ::speech::sparrowhawk::Decimal& decimal() const;
  inline ::speech::sparrowhawk::Decimal* mutable_decimal();
  inline ::speech::sparrowhawk::Decimal* release_decimal();
  inline void set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal);

  // optional .speech.sparrowhawk.Fraction fraction = 18;
  inline bool has_fraction() const;
  inline void clear_fraction();
  static const int kFractionFieldNumber = 18;
  inline const ::speech::sparrowhawk::Fraction& fraction() const;
  inline ::speech::sparrowhawk::Fraction* mutable_fraction();
  inline ::speech::sparrowhawk::Fraction* release_fraction();
  inline void set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction);

  // optional .speech.sparrowhawk.Time time = 19;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 19;
  inline const ::speech::sparrowhawk::Time& time() const;
  inline ::speech::sparrowhawk::Time* mutable_time();
  inline ::speech::sparrowhawk::Time* release_time();
  inline void set_allocated_time(::speech::sparrowhawk::Time* time);

  // optional .speech.sparrowhawk.Measure measure = 20;
  inline bool has_measure() const;
  inline void clear_measure();
  static const int kMeasureFieldNumber = 20;
  inline const ::speech::sparrowhawk::Measure& measure() const;
  inline ::speech::sparrowhawk::Measure* mutable_measure();
  inline ::speech::sparrowhawk::Measure* release_measure();
  inline void set_allocated_measure(::speech::sparrowhawk::Measure* measure);

  // optional .speech.sparrowhawk.Decimal percent = 21;
  inline bool has_percent() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 21;
  inline const ::speech::sparrowhawk::Decimal& percent() const;
  inline ::speech::sparrowhawk::Decimal* mutable_percent();
  inline ::speech::sparrowhawk::Decimal* release_percent();
  inline void set_allocated_percent(::speech::sparrowhawk::Decimal* percent);

  // optional .speech.sparrowhawk.Date date = 22;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 22;
  inline const ::speech::sparrowhawk::Date& date() const;
  inline ::speech::sparrowhawk::Date* mutable_date();
  inline ::speech::sparrowhawk::Date* release_date();
  inline void set_allocated_date(::speech::sparrowhawk::Date* date);

  // optional .speech.sparrowhawk.Telephone telephone = 23;
  inline bool has_telephone() const;
  inline void clear_telephone();
  static const int kTelephoneFieldNumber = 23;
  inline const ::speech::sparrowhawk::Telephone& telephone() const;
  inline ::speech::sparrowhawk::Telephone* mutable_telephone();
  inline ::speech::sparrowhawk::Telephone* release_telephone();
  inline void set_allocated_telephone(::speech::sparrowhawk::Telephone* telephone);

  // optional .speech.sparrowhawk.Money money = 24;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 24;
  inline const ::speech::sparrowhawk::Money& money() const;
  inline ::speech::sparrowhawk::Money* mutable_money();
  inline ::speech::sparrowhawk::Money* release_money();
  inline void set_allocated_money(::speech::sparrowhawk::Money* money);

  // optional .speech.sparrowhawk.Electronic electronic = 25;
  inline bool has_electronic() const;
  inline void clear_electronic();
  static const int kElectronicFieldNumber = 25;
  inline const ::speech::sparrowhawk::Electronic& electronic() const;
  inline ::speech::sparrowhawk::Electronic* mutable_electronic();
  inline ::speech::sparrowhawk::Electronic* release_electronic();
  inline void set_allocated_electronic(::speech::sparrowhawk::Electronic* electronic);

  // optional string verbatim = 26;
  inline bool has_verbatim() const;
  inline void clear_verbatim();
  static const int kVerbatimFieldNumber = 26;
  inline const ::std::string& verbatim() const;
  inline void set_verbatim(const ::std::string& value);
  inline void set_verbatim(const char* value);
  inline void set_verbatim(const char* value, size_t size);
  inline ::std::string* mutable_verbatim();
  inline ::std::string* release_verbatim();
  inline void set_allocated_verbatim(::std::string* verbatim);

  // optional string letters = 27;
  inline bool has_letters() const;
  inline void clear_letters();
  static const int kLettersFieldNumber = 27;
  inline const ::std::string& letters() const;
  inline void set_letters(const ::std::string& value);
  inline void set_letters(const char* value);
  inline void set_letters(const char* value, size_t size);
  inline ::std::string* mutable_letters();
  inline ::std::string* release_letters();
  inline void set_allocated_letters(::std::string* letters);

  // optional .speech.sparrowhawk.Connector connector = 28;
  inline bool has_connector() const;
  inline void clear_connector();
  static const int kConnectorFieldNumber = 28;
  inline const ::speech::sparrowhawk::Connector& connector() const;
  inline ::speech::sparrowhawk::Connector* mutable_connector();
  inline ::speech::sparrowhawk::Connector* release_connector();
  inline void set_allocated_connector(::speech::sparrowhawk::Connector* connector);

  // optional .speech.sparrowhawk.Abbreviation abbreviation = 29;
  inline bool has_abbreviation() const;
  inline void clear_abbreviation();
  static const int kAbbreviationFieldNumber = 29;
  inline const ::speech::sparrowhawk::Abbreviation& abbreviation() const;
  inline ::speech::sparrowhawk::Abbreviation* mutable_abbreviation();
  inline ::speech::sparrowhawk::Abbreviation* release_abbreviation();
  inline void set_allocated_abbreviation(::speech::sparrowhawk::Abbreviation* abbreviation);

  // optional int32 first_daughter = 30;
  inline bool has_first_daughter() const;
  inline void clear_first_daughter();
  static const int kFirstDaughterFieldNumber = 30;
  inline ::google::protobuf::int32 first_daughter() const;
  inline void set_first_daughter(::google::protobuf::int32 value);

  // optional int32 last_daughter = 31;
  inline bool has_last_daughter() const;
  inline void clear_last_daughter();
  static const int kLastDaughterFieldNumber = 31;
  inline ::google::protobuf::int32 last_daughter() const;
  inline void set_last_daughter(::google::protobuf::int32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Token)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Token)
 private:
  inline void set_has_links();
  inline void clear_has_links();
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_end_index();
  inline void clear_has_end_index();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_wordid();
  inline void clear_has_wordid();
  inline void set_has_spelling();
  inline void clear_has_spelling();
  inline void set_has_phrase_break();
  inline void clear_has_phrase_break();
  inline void set_has_pause_duration();
  inline void clear_has_pause_duration();
  inline void set_has_pause_length();
  inline void clear_has_pause_length();
  inline void set_has_spelling_with_stress();
  inline void clear_has_spelling_with_stress();
  inline void set_has_skip();
  inline void clear_has_skip();
  inline void set_has_next_space();
  inline void clear_has_next_space();
  inline void set_has_cardinal();
  inline void clear_has_cardinal();
  inline void set_has_ordinal();
  inline void clear_has_ordinal();
  inline void set_has_digit();
  inline void clear_has_digit();
  inline void set_has_decimal();
  inline void clear_has_decimal();
  inline void set_has_fraction();
  inline void clear_has_fraction();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_measure();
  inline void clear_has_measure();
  inline void set_has_percent();
  inline void clear_has_percent();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_telephone();
  inline void clear_has_telephone();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_electronic();
  inline void clear_has_electronic();
  inline void set_has_verbatim();
  inline void clear_has_verbatim();
  inline void set_has_letters();
  inline void clear_has_letters();
  inline void set_has_connector();
  inline void clear_has_connector();
  inline void set_has_abbreviation();
  inline void clear_has_abbreviation();
  inline void set_has_first_daughter();
  inline void clear_has_first_daughter();
  inline void set_has_last_daughter();
  inline void clear_has_last_daughter();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::speech::sparrowhawk::Links* links_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::uint32 end_index_;
  ::std::string* name_;
  ::std::string* wordid_;
  ::std::string* spelling_;
  int type_;
  float pause_duration_;
  int pause_length_;
  bool phrase_break_;
  bool skip_;
  bool next_space_;
  ::std::string* spelling_with_stress_;
  ::speech::sparrowhawk::Cardinal* cardinal_;
  ::speech::sparrowhawk::Ordinal* ordinal_;
  ::std::string* digit_;
  ::speech::sparrowhawk::Decimal* decimal_;
  ::speech::sparrowhawk::Fraction* fraction_;
  ::speech::sparrowhawk::Time* time_;
  ::speech::sparrowhawk::Measure* measure_;
  ::speech::sparrowhawk::Decimal* percent_;
  ::speech::sparrowhawk::Date* date_;
  ::speech::sparrowhawk::Telephone* telephone_;
  ::speech::sparrowhawk::Money* money_;
  ::speech::sparrowhawk::Electronic* electronic_;
  ::std::string* verbatim_;
  ::std::string* letters_;
  ::speech::sparrowhawk::Connector* connector_;
  ::speech::sparrowhawk::Abbreviation* abbreviation_;
  ::google::protobuf::int32 first_daughter_;
  ::google::protobuf::int32 last_daughter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void  protobuf_AddDesc_items_2eproto();
  friend void protobuf_AssignDesc_items_2eproto();
  friend void protobuf_ShutdownFile_items_2eproto();

  void InitAsDefaultInstance();
  static Token* default_instance_;
};
// -------------------------------------------------------------------

class Word : public ::google::protobuf::Message {
 public:
  Word();
  virtual ~Word();

  Word(const Word& from);

  inline Word& operator=(const Word& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Word& default_instance();

  void Swap(Word* other);

  // implements Message ----------------------------------------------

  Word* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Word& from);
  void MergeFrom(const Word& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .speech.sparrowhawk.Links links = 1;
  inline bool has_links() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 1;
  inline const ::speech::sparrowhawk::Links& links() const;
  inline ::speech::sparrowhawk::Links* mutable_links();
  inline ::speech::sparrowhawk::Links* release_links();
  inline void set_allocated_links(::speech::sparrowhawk::Links* links);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string spelling = 3;
  inline bool has_spelling() const;
  inline void clear_spelling();
  static const int kSpellingFieldNumber = 3;
  inline const ::std::string& spelling() const;
  inline void set_spelling(const ::std::string& value);
  inline void set_spelling(const char* value);
  inline void set_spelling(const char* value, size_t size);
  inline ::std::string* mutable_spelling();
  inline ::std::string* release_spelling();
  inline void set_allocated_spelling(::std::string* spelling);

  // optional float pause_length = 4;
  inline bool has_pause_length() const;
  inline void clear_pause_length();
  static const int kPauseLengthFieldNumber = 4;
  inline float pause_length() const;
  inline void set_pause_length(float value);

  // optional bool precedes_pause = 5;
  inline bool has_precedes_pause() const;
  inline void clear_precedes_pause();
  static const int kPrecedesPauseFieldNumber = 5;
  inline bool precedes_pause() const;
  inline void set_precedes_pause(bool value);

  // optional int32 parent = 6;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 6;
  inline ::google::protobuf::int32 parent() const;
  inline void set_parent(::google::protobuf::int32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Word)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Word)
 private:
  inline void set_has_links();
  inline void clear_has_links();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_spelling();
  inline void clear_has_spelling();
  inline void set_has_pause_length();
  inline void clear_has_pause_length();
  inline void set_has_precedes_pause();
  inline void clear_has_precedes_pause();
  inline void set_has_parent();
  inline void clear_has_parent();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::speech::sparrowhawk::Links* links_;
  ::std::string* id_;
  ::std::string* spelling_;
  float pause_length_;
  bool precedes_pause_;
  ::google::protobuf::int32 parent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_items_2eproto();
  friend void protobuf_AssignDesc_items_2eproto();
  friend void protobuf_ShutdownFile_items_2eproto();

  void InitAsDefaultInstance();
  static Word* default_instance_;
};
// -------------------------------------------------------------------

class LinguisticStructure : public ::google::protobuf::Message {
 public:
  LinguisticStructure();
  virtual ~LinguisticStructure();

  LinguisticStructure(const LinguisticStructure& from);

  inline LinguisticStructure& operator=(const LinguisticStructure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinguisticStructure& default_instance();

  void Swap(LinguisticStructure* other);

  // implements Message ----------------------------------------------

  LinguisticStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinguisticStructure& from);
  void MergeFrom(const LinguisticStructure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional string input = 2;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::std::string& input() const;
  inline void set_input(const ::std::string& value);
  inline void set_input(const char* value);
  inline void set_input(const char* value, size_t size);
  inline ::std::string* mutable_input();
  inline ::std::string* release_input();
  inline void set_allocated_input(::std::string* input);

  // repeated .speech.sparrowhawk.Token tokens = 3;
  inline int tokens_size() const;
  inline void clear_tokens();
  static const int kTokensFieldNumber = 3;
  inline const ::speech::sparrowhawk::Token& tokens(int index) const;
  inline ::speech::sparrowhawk::Token* mutable_tokens(int index);
  inline ::speech::sparrowhawk::Token* add_tokens();
  inline const ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token >&
      tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token >*
      mutable_tokens();

  // repeated .speech.sparrowhawk.Word words = 4;
  inline int words_size() const;
  inline void clear_words();
  static const int kWordsFieldNumber = 4;
  inline const ::speech::sparrowhawk::Word& words(int index) const;
  inline ::speech::sparrowhawk::Word* mutable_words(int index);
  inline ::speech::sparrowhawk::Word* add_words();
  inline const ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word >&
      words() const;
  inline ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word >*
      mutable_words();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(LinguisticStructure)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.LinguisticStructure)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_input();
  inline void clear_has_input();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::std::string* input_;
  ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token > tokens_;
  ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word > words_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_items_2eproto();
  friend void protobuf_AssignDesc_items_2eproto();
  friend void protobuf_ShutdownFile_items_2eproto();

  void InitAsDefaultInstance();
  static LinguisticStructure* default_instance_;
};
// -------------------------------------------------------------------

class Utterance : public ::google::protobuf::Message {
 public:
  Utterance();
  virtual ~Utterance();

  Utterance(const Utterance& from);

  inline Utterance& operator=(const Utterance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Utterance& default_instance();

  void Swap(Utterance* other);

  // implements Message ----------------------------------------------

  Utterance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Utterance& from);
  void MergeFrom(const Utterance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string filename = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string sentence = 3;
  inline bool has_sentence() const;
  inline void clear_sentence();
  static const int kSentenceFieldNumber = 3;
  inline const ::std::string& sentence() const;
  inline void set_sentence(const ::std::string& value);
  inline void set_sentence(const char* value);
  inline void set_sentence(const char* value, size_t size);
  inline ::std::string* mutable_sentence();
  inline ::std::string* release_sentence();
  inline void set_allocated_sentence(::std::string* sentence);

  // optional string original_sentence = 4;
  inline bool has_original_sentence() const;
  inline void clear_original_sentence();
  static const int kOriginalSentenceFieldNumber = 4;
  inline const ::std::string& original_sentence() const;
  inline void set_original_sentence(const ::std::string& value);
  inline void set_original_sentence(const char* value);
  inline void set_original_sentence(const char* value, size_t size);
  inline ::std::string* mutable_original_sentence();
  inline ::std::string* release_original_sentence();
  inline void set_allocated_original_sentence(::std::string* original_sentence);

  // repeated string segmenter_output = 5;
  inline int segmenter_output_size() const;
  inline void clear_segmenter_output();
  static const int kSegmenterOutputFieldNumber = 5;
  inline const ::std::string& segmenter_output(int index) const;
  inline ::std::string* mutable_segmenter_output(int index);
  inline void set_segmenter_output(int index, const ::std::string& value);
  inline void set_segmenter_output(int index, const char* value);
  inline void set_segmenter_output(int index, const char* value, size_t size);
  inline ::std::string* add_segmenter_output();
  inline void add_segmenter_output(const ::std::string& value);
  inline void add_segmenter_output(const char* value);
  inline void add_segmenter_output(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& segmenter_output() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_segmenter_output();

  // optional .speech.sparrowhawk.LinguisticStructure linguistic = 6;
  inline bool has_linguistic() const;
  inline void clear_linguistic();
  static const int kLinguisticFieldNumber = 6;
  inline const ::speech::sparrowhawk::LinguisticStructure& linguistic() const;
  inline ::speech::sparrowhawk::LinguisticStructure* mutable_linguistic();
  inline ::speech::sparrowhawk::LinguisticStructure* release_linguistic();
  inline void set_allocated_linguistic(::speech::sparrowhawk::LinguisticStructure* linguistic);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Utterance)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Utterance)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_sentence();
  inline void clear_has_sentence();
  inline void set_has_original_sentence();
  inline void clear_has_original_sentence();
  inline void set_has_linguistic();
  inline void clear_has_linguistic();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* filename_;
  ::std::string* sentence_;
  ::std::string* original_sentence_;
  ::google::protobuf::RepeatedPtrField< ::std::string> segmenter_output_;
  ::speech::sparrowhawk::LinguisticStructure* linguistic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_items_2eproto();
  friend void protobuf_AssignDesc_items_2eproto();
  friend void protobuf_ShutdownFile_items_2eproto();

  void InitAsDefaultInstance();
  static Utterance* default_instance_;
};
// ===================================================================


// ===================================================================

// Token

// optional .speech.sparrowhawk.Links links = 1;
inline bool Token::has_links() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Token::set_has_links() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Token::clear_has_links() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Token::clear_links() {
  if (links_ != NULL) links_->::speech::sparrowhawk::Links::Clear();
  clear_has_links();
}
inline const ::speech::sparrowhawk::Links& Token::links() const {
  return links_ != NULL ? *links_ : *default_instance_->links_;
}
inline ::speech::sparrowhawk::Links* Token::mutable_links() {
  set_has_links();
  if (links_ == NULL) links_ = new ::speech::sparrowhawk::Links;
  return links_;
}
inline ::speech::sparrowhawk::Links* Token::release_links() {
  clear_has_links();
  ::speech::sparrowhawk::Links* temp = links_;
  links_ = NULL;
  return temp;
}
inline void Token::set_allocated_links(::speech::sparrowhawk::Links* links) {
  delete links_;
  links_ = links;
  if (links) {
    set_has_links();
  } else {
    clear_has_links();
  }
}

// optional uint32 start_index = 2;
inline bool Token::has_start_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Token::set_has_start_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Token::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Token::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 Token::start_index() const {
  return start_index_;
}
inline void Token::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional uint32 end_index = 3;
inline bool Token::has_end_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Token::set_has_end_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Token::clear_has_end_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Token::clear_end_index() {
  end_index_ = 0u;
  clear_has_end_index();
}
inline ::google::protobuf::uint32 Token::end_index() const {
  return end_index_;
}
inline void Token::set_end_index(::google::protobuf::uint32 value) {
  set_has_end_index();
  end_index_ = value;
}

// optional string name = 4;
inline bool Token::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Token::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Token::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Token::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Token::name() const {
  return *name_;
}
inline void Token::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Token::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Token::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Token::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Token::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .speech.sparrowhawk.Token.Type type = 5;
inline bool Token::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Token::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Token::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Token::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::speech::sparrowhawk::Token_Type Token::type() const {
  return static_cast< ::speech::sparrowhawk::Token_Type >(type_);
}
inline void Token::set_type(::speech::sparrowhawk::Token_Type value) {
  assert(::speech::sparrowhawk::Token_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string wordid = 6;
inline bool Token::has_wordid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Token::set_has_wordid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Token::clear_has_wordid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Token::clear_wordid() {
  if (wordid_ != &::google::protobuf::internal::kEmptyString) {
    wordid_->clear();
  }
  clear_has_wordid();
}
inline const ::std::string& Token::wordid() const {
  return *wordid_;
}
inline void Token::set_wordid(const ::std::string& value) {
  set_has_wordid();
  if (wordid_ == &::google::protobuf::internal::kEmptyString) {
    wordid_ = new ::std::string;
  }
  wordid_->assign(value);
}
inline void Token::set_wordid(const char* value) {
  set_has_wordid();
  if (wordid_ == &::google::protobuf::internal::kEmptyString) {
    wordid_ = new ::std::string;
  }
  wordid_->assign(value);
}
inline void Token::set_wordid(const char* value, size_t size) {
  set_has_wordid();
  if (wordid_ == &::google::protobuf::internal::kEmptyString) {
    wordid_ = new ::std::string;
  }
  wordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_wordid() {
  set_has_wordid();
  if (wordid_ == &::google::protobuf::internal::kEmptyString) {
    wordid_ = new ::std::string;
  }
  return wordid_;
}
inline ::std::string* Token::release_wordid() {
  clear_has_wordid();
  if (wordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wordid_;
    wordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Token::set_allocated_wordid(::std::string* wordid) {
  if (wordid_ != &::google::protobuf::internal::kEmptyString) {
    delete wordid_;
  }
  if (wordid) {
    set_has_wordid();
    wordid_ = wordid;
  } else {
    clear_has_wordid();
    wordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string spelling = 7;
inline bool Token::has_spelling() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Token::set_has_spelling() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Token::clear_has_spelling() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Token::clear_spelling() {
  if (spelling_ != &::google::protobuf::internal::kEmptyString) {
    spelling_->clear();
  }
  clear_has_spelling();
}
inline const ::std::string& Token::spelling() const {
  return *spelling_;
}
inline void Token::set_spelling(const ::std::string& value) {
  set_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    spelling_ = new ::std::string;
  }
  spelling_->assign(value);
}
inline void Token::set_spelling(const char* value) {
  set_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    spelling_ = new ::std::string;
  }
  spelling_->assign(value);
}
inline void Token::set_spelling(const char* value, size_t size) {
  set_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    spelling_ = new ::std::string;
  }
  spelling_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_spelling() {
  set_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    spelling_ = new ::std::string;
  }
  return spelling_;
}
inline ::std::string* Token::release_spelling() {
  clear_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spelling_;
    spelling_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Token::set_allocated_spelling(::std::string* spelling) {
  if (spelling_ != &::google::protobuf::internal::kEmptyString) {
    delete spelling_;
  }
  if (spelling) {
    set_has_spelling();
    spelling_ = spelling;
  } else {
    clear_has_spelling();
    spelling_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool phrase_break = 8;
inline bool Token::has_phrase_break() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Token::set_has_phrase_break() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Token::clear_has_phrase_break() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Token::clear_phrase_break() {
  phrase_break_ = false;
  clear_has_phrase_break();
}
inline bool Token::phrase_break() const {
  return phrase_break_;
}
inline void Token::set_phrase_break(bool value) {
  set_has_phrase_break();
  phrase_break_ = value;
}

// optional float pause_duration = 9;
inline bool Token::has_pause_duration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Token::set_has_pause_duration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Token::clear_has_pause_duration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Token::clear_pause_duration() {
  pause_duration_ = 0;
  clear_has_pause_duration();
}
inline float Token::pause_duration() const {
  return pause_duration_;
}
inline void Token::set_pause_duration(float value) {
  set_has_pause_duration();
  pause_duration_ = value;
}

// optional .speech.sparrowhawk.Token.PauseLength pause_length = 10 [default = PAUSE_NONE];
inline bool Token::has_pause_length() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Token::set_has_pause_length() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Token::clear_has_pause_length() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Token::clear_pause_length() {
  pause_length_ = 0;
  clear_has_pause_length();
}
inline ::speech::sparrowhawk::Token_PauseLength Token::pause_length() const {
  return static_cast< ::speech::sparrowhawk::Token_PauseLength >(pause_length_);
}
inline void Token::set_pause_length(::speech::sparrowhawk::Token_PauseLength value) {
  assert(::speech::sparrowhawk::Token_PauseLength_IsValid(value));
  set_has_pause_length();
  pause_length_ = value;
}

// optional string spelling_with_stress = 11;
inline bool Token::has_spelling_with_stress() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Token::set_has_spelling_with_stress() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Token::clear_has_spelling_with_stress() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Token::clear_spelling_with_stress() {
  if (spelling_with_stress_ != &::google::protobuf::internal::kEmptyString) {
    spelling_with_stress_->clear();
  }
  clear_has_spelling_with_stress();
}
inline const ::std::string& Token::spelling_with_stress() const {
  return *spelling_with_stress_;
}
inline void Token::set_spelling_with_stress(const ::std::string& value) {
  set_has_spelling_with_stress();
  if (spelling_with_stress_ == &::google::protobuf::internal::kEmptyString) {
    spelling_with_stress_ = new ::std::string;
  }
  spelling_with_stress_->assign(value);
}
inline void Token::set_spelling_with_stress(const char* value) {
  set_has_spelling_with_stress();
  if (spelling_with_stress_ == &::google::protobuf::internal::kEmptyString) {
    spelling_with_stress_ = new ::std::string;
  }
  spelling_with_stress_->assign(value);
}
inline void Token::set_spelling_with_stress(const char* value, size_t size) {
  set_has_spelling_with_stress();
  if (spelling_with_stress_ == &::google::protobuf::internal::kEmptyString) {
    spelling_with_stress_ = new ::std::string;
  }
  spelling_with_stress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_spelling_with_stress() {
  set_has_spelling_with_stress();
  if (spelling_with_stress_ == &::google::protobuf::internal::kEmptyString) {
    spelling_with_stress_ = new ::std::string;
  }
  return spelling_with_stress_;
}
inline ::std::string* Token::release_spelling_with_stress() {
  clear_has_spelling_with_stress();
  if (spelling_with_stress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spelling_with_stress_;
    spelling_with_stress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Token::set_allocated_spelling_with_stress(::std::string* spelling_with_stress) {
  if (spelling_with_stress_ != &::google::protobuf::internal::kEmptyString) {
    delete spelling_with_stress_;
  }
  if (spelling_with_stress) {
    set_has_spelling_with_stress();
    spelling_with_stress_ = spelling_with_stress;
  } else {
    clear_has_spelling_with_stress();
    spelling_with_stress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool skip = 12;
inline bool Token::has_skip() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Token::set_has_skip() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Token::clear_has_skip() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Token::clear_skip() {
  skip_ = false;
  clear_has_skip();
}
inline bool Token::skip() const {
  return skip_;
}
inline void Token::set_skip(bool value) {
  set_has_skip();
  skip_ = value;
}

// optional bool next_space = 13;
inline bool Token::has_next_space() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Token::set_has_next_space() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Token::clear_has_next_space() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Token::clear_next_space() {
  next_space_ = false;
  clear_has_next_space();
}
inline bool Token::next_space() const {
  return next_space_;
}
inline void Token::set_next_space(bool value) {
  set_has_next_space();
  next_space_ = value;
}

// optional .speech.sparrowhawk.Cardinal cardinal = 14;
inline bool Token::has_cardinal() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Token::set_has_cardinal() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Token::clear_has_cardinal() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Token::clear_cardinal() {
  if (cardinal_ != NULL) cardinal_->::speech::sparrowhawk::Cardinal::Clear();
  clear_has_cardinal();
}
inline const ::speech::sparrowhawk::Cardinal& Token::cardinal() const {
  return cardinal_ != NULL ? *cardinal_ : *default_instance_->cardinal_;
}
inline ::speech::sparrowhawk::Cardinal* Token::mutable_cardinal() {
  set_has_cardinal();
  if (cardinal_ == NULL) cardinal_ = new ::speech::sparrowhawk::Cardinal;
  return cardinal_;
}
inline ::speech::sparrowhawk::Cardinal* Token::release_cardinal() {
  clear_has_cardinal();
  ::speech::sparrowhawk::Cardinal* temp = cardinal_;
  cardinal_ = NULL;
  return temp;
}
inline void Token::set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal) {
  delete cardinal_;
  cardinal_ = cardinal;
  if (cardinal) {
    set_has_cardinal();
  } else {
    clear_has_cardinal();
  }
}

// optional .speech.sparrowhawk.Ordinal ordinal = 15;
inline bool Token::has_ordinal() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Token::set_has_ordinal() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Token::clear_has_ordinal() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Token::clear_ordinal() {
  if (ordinal_ != NULL) ordinal_->::speech::sparrowhawk::Ordinal::Clear();
  clear_has_ordinal();
}
inline const ::speech::sparrowhawk::Ordinal& Token::ordinal() const {
  return ordinal_ != NULL ? *ordinal_ : *default_instance_->ordinal_;
}
inline ::speech::sparrowhawk::Ordinal* Token::mutable_ordinal() {
  set_has_ordinal();
  if (ordinal_ == NULL) ordinal_ = new ::speech::sparrowhawk::Ordinal;
  return ordinal_;
}
inline ::speech::sparrowhawk::Ordinal* Token::release_ordinal() {
  clear_has_ordinal();
  ::speech::sparrowhawk::Ordinal* temp = ordinal_;
  ordinal_ = NULL;
  return temp;
}
inline void Token::set_allocated_ordinal(::speech::sparrowhawk::Ordinal* ordinal) {
  delete ordinal_;
  ordinal_ = ordinal;
  if (ordinal) {
    set_has_ordinal();
  } else {
    clear_has_ordinal();
  }
}

// optional string digit = 16;
inline bool Token::has_digit() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Token::set_has_digit() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Token::clear_has_digit() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Token::clear_digit() {
  if (digit_ != &::google::protobuf::internal::kEmptyString) {
    digit_->clear();
  }
  clear_has_digit();
}
inline const ::std::string& Token::digit() const {
  return *digit_;
}
inline void Token::set_digit(const ::std::string& value) {
  set_has_digit();
  if (digit_ == &::google::protobuf::internal::kEmptyString) {
    digit_ = new ::std::string;
  }
  digit_->assign(value);
}
inline void Token::set_digit(const char* value) {
  set_has_digit();
  if (digit_ == &::google::protobuf::internal::kEmptyString) {
    digit_ = new ::std::string;
  }
  digit_->assign(value);
}
inline void Token::set_digit(const char* value, size_t size) {
  set_has_digit();
  if (digit_ == &::google::protobuf::internal::kEmptyString) {
    digit_ = new ::std::string;
  }
  digit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_digit() {
  set_has_digit();
  if (digit_ == &::google::protobuf::internal::kEmptyString) {
    digit_ = new ::std::string;
  }
  return digit_;
}
inline ::std::string* Token::release_digit() {
  clear_has_digit();
  if (digit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = digit_;
    digit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Token::set_allocated_digit(::std::string* digit) {
  if (digit_ != &::google::protobuf::internal::kEmptyString) {
    delete digit_;
  }
  if (digit) {
    set_has_digit();
    digit_ = digit;
  } else {
    clear_has_digit();
    digit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .speech.sparrowhawk.Decimal decimal = 17;
inline bool Token::has_decimal() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Token::set_has_decimal() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Token::clear_has_decimal() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Token::clear_decimal() {
  if (decimal_ != NULL) decimal_->::speech::sparrowhawk::Decimal::Clear();
  clear_has_decimal();
}
inline const ::speech::sparrowhawk::Decimal& Token::decimal() const {
  return decimal_ != NULL ? *decimal_ : *default_instance_->decimal_;
}
inline ::speech::sparrowhawk::Decimal* Token::mutable_decimal() {
  set_has_decimal();
  if (decimal_ == NULL) decimal_ = new ::speech::sparrowhawk::Decimal;
  return decimal_;
}
inline ::speech::sparrowhawk::Decimal* Token::release_decimal() {
  clear_has_decimal();
  ::speech::sparrowhawk::Decimal* temp = decimal_;
  decimal_ = NULL;
  return temp;
}
inline void Token::set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal) {
  delete decimal_;
  decimal_ = decimal;
  if (decimal) {
    set_has_decimal();
  } else {
    clear_has_decimal();
  }
}

// optional .speech.sparrowhawk.Fraction fraction = 18;
inline bool Token::has_fraction() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Token::set_has_fraction() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Token::clear_has_fraction() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Token::clear_fraction() {
  if (fraction_ != NULL) fraction_->::speech::sparrowhawk::Fraction::Clear();
  clear_has_fraction();
}
inline const ::speech::sparrowhawk::Fraction& Token::fraction() const {
  return fraction_ != NULL ? *fraction_ : *default_instance_->fraction_;
}
inline ::speech::sparrowhawk::Fraction* Token::mutable_fraction() {
  set_has_fraction();
  if (fraction_ == NULL) fraction_ = new ::speech::sparrowhawk::Fraction;
  return fraction_;
}
inline ::speech::sparrowhawk::Fraction* Token::release_fraction() {
  clear_has_fraction();
  ::speech::sparrowhawk::Fraction* temp = fraction_;
  fraction_ = NULL;
  return temp;
}
inline void Token::set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction) {
  delete fraction_;
  fraction_ = fraction;
  if (fraction) {
    set_has_fraction();
  } else {
    clear_has_fraction();
  }
}

// optional .speech.sparrowhawk.Time time = 19;
inline bool Token::has_time() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Token::set_has_time() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Token::clear_has_time() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Token::clear_time() {
  if (time_ != NULL) time_->::speech::sparrowhawk::Time::Clear();
  clear_has_time();
}
inline const ::speech::sparrowhawk::Time& Token::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::speech::sparrowhawk::Time* Token::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::speech::sparrowhawk::Time;
  return time_;
}
inline ::speech::sparrowhawk::Time* Token::release_time() {
  clear_has_time();
  ::speech::sparrowhawk::Time* temp = time_;
  time_ = NULL;
  return temp;
}
inline void Token::set_allocated_time(::speech::sparrowhawk::Time* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
}

// optional .speech.sparrowhawk.Measure measure = 20;
inline bool Token::has_measure() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Token::set_has_measure() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Token::clear_has_measure() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Token::clear_measure() {
  if (measure_ != NULL) measure_->::speech::sparrowhawk::Measure::Clear();
  clear_has_measure();
}
inline const ::speech::sparrowhawk::Measure& Token::measure() const {
  return measure_ != NULL ? *measure_ : *default_instance_->measure_;
}
inline ::speech::sparrowhawk::Measure* Token::mutable_measure() {
  set_has_measure();
  if (measure_ == NULL) measure_ = new ::speech::sparrowhawk::Measure;
  return measure_;
}
inline ::speech::sparrowhawk::Measure* Token::release_measure() {
  clear_has_measure();
  ::speech::sparrowhawk::Measure* temp = measure_;
  measure_ = NULL;
  return temp;
}
inline void Token::set_allocated_measure(::speech::sparrowhawk::Measure* measure) {
  delete measure_;
  measure_ = measure;
  if (measure) {
    set_has_measure();
  } else {
    clear_has_measure();
  }
}

// optional .speech.sparrowhawk.Decimal percent = 21;
inline bool Token::has_percent() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Token::set_has_percent() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Token::clear_has_percent() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Token::clear_percent() {
  if (percent_ != NULL) percent_->::speech::sparrowhawk::Decimal::Clear();
  clear_has_percent();
}
inline const ::speech::sparrowhawk::Decimal& Token::percent() const {
  return percent_ != NULL ? *percent_ : *default_instance_->percent_;
}
inline ::speech::sparrowhawk::Decimal* Token::mutable_percent() {
  set_has_percent();
  if (percent_ == NULL) percent_ = new ::speech::sparrowhawk::Decimal;
  return percent_;
}
inline ::speech::sparrowhawk::Decimal* Token::release_percent() {
  clear_has_percent();
  ::speech::sparrowhawk::Decimal* temp = percent_;
  percent_ = NULL;
  return temp;
}
inline void Token::set_allocated_percent(::speech::sparrowhawk::Decimal* percent) {
  delete percent_;
  percent_ = percent;
  if (percent) {
    set_has_percent();
  } else {
    clear_has_percent();
  }
}

// optional .speech.sparrowhawk.Date date = 22;
inline bool Token::has_date() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Token::set_has_date() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Token::clear_has_date() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Token::clear_date() {
  if (date_ != NULL) date_->::speech::sparrowhawk::Date::Clear();
  clear_has_date();
}
inline const ::speech::sparrowhawk::Date& Token::date() const {
  return date_ != NULL ? *date_ : *default_instance_->date_;
}
inline ::speech::sparrowhawk::Date* Token::mutable_date() {
  set_has_date();
  if (date_ == NULL) date_ = new ::speech::sparrowhawk::Date;
  return date_;
}
inline ::speech::sparrowhawk::Date* Token::release_date() {
  clear_has_date();
  ::speech::sparrowhawk::Date* temp = date_;
  date_ = NULL;
  return temp;
}
inline void Token::set_allocated_date(::speech::sparrowhawk::Date* date) {
  delete date_;
  date_ = date;
  if (date) {
    set_has_date();
  } else {
    clear_has_date();
  }
}

// optional .speech.sparrowhawk.Telephone telephone = 23;
inline bool Token::has_telephone() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Token::set_has_telephone() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Token::clear_has_telephone() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Token::clear_telephone() {
  if (telephone_ != NULL) telephone_->::speech::sparrowhawk::Telephone::Clear();
  clear_has_telephone();
}
inline const ::speech::sparrowhawk::Telephone& Token::telephone() const {
  return telephone_ != NULL ? *telephone_ : *default_instance_->telephone_;
}
inline ::speech::sparrowhawk::Telephone* Token::mutable_telephone() {
  set_has_telephone();
  if (telephone_ == NULL) telephone_ = new ::speech::sparrowhawk::Telephone;
  return telephone_;
}
inline ::speech::sparrowhawk::Telephone* Token::release_telephone() {
  clear_has_telephone();
  ::speech::sparrowhawk::Telephone* temp = telephone_;
  telephone_ = NULL;
  return temp;
}
inline void Token::set_allocated_telephone(::speech::sparrowhawk::Telephone* telephone) {
  delete telephone_;
  telephone_ = telephone;
  if (telephone) {
    set_has_telephone();
  } else {
    clear_has_telephone();
  }
}

// optional .speech.sparrowhawk.Money money = 24;
inline bool Token::has_money() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Token::set_has_money() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Token::clear_has_money() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Token::clear_money() {
  if (money_ != NULL) money_->::speech::sparrowhawk::Money::Clear();
  clear_has_money();
}
inline const ::speech::sparrowhawk::Money& Token::money() const {
  return money_ != NULL ? *money_ : *default_instance_->money_;
}
inline ::speech::sparrowhawk::Money* Token::mutable_money() {
  set_has_money();
  if (money_ == NULL) money_ = new ::speech::sparrowhawk::Money;
  return money_;
}
inline ::speech::sparrowhawk::Money* Token::release_money() {
  clear_has_money();
  ::speech::sparrowhawk::Money* temp = money_;
  money_ = NULL;
  return temp;
}
inline void Token::set_allocated_money(::speech::sparrowhawk::Money* money) {
  delete money_;
  money_ = money;
  if (money) {
    set_has_money();
  } else {
    clear_has_money();
  }
}

// optional .speech.sparrowhawk.Electronic electronic = 25;
inline bool Token::has_electronic() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Token::set_has_electronic() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Token::clear_has_electronic() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Token::clear_electronic() {
  if (electronic_ != NULL) electronic_->::speech::sparrowhawk::Electronic::Clear();
  clear_has_electronic();
}
inline const ::speech::sparrowhawk::Electronic& Token::electronic() const {
  return electronic_ != NULL ? *electronic_ : *default_instance_->electronic_;
}
inline ::speech::sparrowhawk::Electronic* Token::mutable_electronic() {
  set_has_electronic();
  if (electronic_ == NULL) electronic_ = new ::speech::sparrowhawk::Electronic;
  return electronic_;
}
inline ::speech::sparrowhawk::Electronic* Token::release_electronic() {
  clear_has_electronic();
  ::speech::sparrowhawk::Electronic* temp = electronic_;
  electronic_ = NULL;
  return temp;
}
inline void Token::set_allocated_electronic(::speech::sparrowhawk::Electronic* electronic) {
  delete electronic_;
  electronic_ = electronic;
  if (electronic) {
    set_has_electronic();
  } else {
    clear_has_electronic();
  }
}

// optional string verbatim = 26;
inline bool Token::has_verbatim() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Token::set_has_verbatim() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Token::clear_has_verbatim() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Token::clear_verbatim() {
  if (verbatim_ != &::google::protobuf::internal::kEmptyString) {
    verbatim_->clear();
  }
  clear_has_verbatim();
}
inline const ::std::string& Token::verbatim() const {
  return *verbatim_;
}
inline void Token::set_verbatim(const ::std::string& value) {
  set_has_verbatim();
  if (verbatim_ == &::google::protobuf::internal::kEmptyString) {
    verbatim_ = new ::std::string;
  }
  verbatim_->assign(value);
}
inline void Token::set_verbatim(const char* value) {
  set_has_verbatim();
  if (verbatim_ == &::google::protobuf::internal::kEmptyString) {
    verbatim_ = new ::std::string;
  }
  verbatim_->assign(value);
}
inline void Token::set_verbatim(const char* value, size_t size) {
  set_has_verbatim();
  if (verbatim_ == &::google::protobuf::internal::kEmptyString) {
    verbatim_ = new ::std::string;
  }
  verbatim_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_verbatim() {
  set_has_verbatim();
  if (verbatim_ == &::google::protobuf::internal::kEmptyString) {
    verbatim_ = new ::std::string;
  }
  return verbatim_;
}
inline ::std::string* Token::release_verbatim() {
  clear_has_verbatim();
  if (verbatim_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbatim_;
    verbatim_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Token::set_allocated_verbatim(::std::string* verbatim) {
  if (verbatim_ != &::google::protobuf::internal::kEmptyString) {
    delete verbatim_;
  }
  if (verbatim) {
    set_has_verbatim();
    verbatim_ = verbatim;
  } else {
    clear_has_verbatim();
    verbatim_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string letters = 27;
inline bool Token::has_letters() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Token::set_has_letters() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Token::clear_has_letters() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Token::clear_letters() {
  if (letters_ != &::google::protobuf::internal::kEmptyString) {
    letters_->clear();
  }
  clear_has_letters();
}
inline const ::std::string& Token::letters() const {
  return *letters_;
}
inline void Token::set_letters(const ::std::string& value) {
  set_has_letters();
  if (letters_ == &::google::protobuf::internal::kEmptyString) {
    letters_ = new ::std::string;
  }
  letters_->assign(value);
}
inline void Token::set_letters(const char* value) {
  set_has_letters();
  if (letters_ == &::google::protobuf::internal::kEmptyString) {
    letters_ = new ::std::string;
  }
  letters_->assign(value);
}
inline void Token::set_letters(const char* value, size_t size) {
  set_has_letters();
  if (letters_ == &::google::protobuf::internal::kEmptyString) {
    letters_ = new ::std::string;
  }
  letters_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Token::mutable_letters() {
  set_has_letters();
  if (letters_ == &::google::protobuf::internal::kEmptyString) {
    letters_ = new ::std::string;
  }
  return letters_;
}
inline ::std::string* Token::release_letters() {
  clear_has_letters();
  if (letters_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = letters_;
    letters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Token::set_allocated_letters(::std::string* letters) {
  if (letters_ != &::google::protobuf::internal::kEmptyString) {
    delete letters_;
  }
  if (letters) {
    set_has_letters();
    letters_ = letters;
  } else {
    clear_has_letters();
    letters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .speech.sparrowhawk.Connector connector = 28;
inline bool Token::has_connector() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Token::set_has_connector() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Token::clear_has_connector() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Token::clear_connector() {
  if (connector_ != NULL) connector_->::speech::sparrowhawk::Connector::Clear();
  clear_has_connector();
}
inline const ::speech::sparrowhawk::Connector& Token::connector() const {
  return connector_ != NULL ? *connector_ : *default_instance_->connector_;
}
inline ::speech::sparrowhawk::Connector* Token::mutable_connector() {
  set_has_connector();
  if (connector_ == NULL) connector_ = new ::speech::sparrowhawk::Connector;
  return connector_;
}
inline ::speech::sparrowhawk::Connector* Token::release_connector() {
  clear_has_connector();
  ::speech::sparrowhawk::Connector* temp = connector_;
  connector_ = NULL;
  return temp;
}
inline void Token::set_allocated_connector(::speech::sparrowhawk::Connector* connector) {
  delete connector_;
  connector_ = connector;
  if (connector) {
    set_has_connector();
  } else {
    clear_has_connector();
  }
}

// optional .speech.sparrowhawk.Abbreviation abbreviation = 29;
inline bool Token::has_abbreviation() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Token::set_has_abbreviation() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Token::clear_has_abbreviation() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Token::clear_abbreviation() {
  if (abbreviation_ != NULL) abbreviation_->::speech::sparrowhawk::Abbreviation::Clear();
  clear_has_abbreviation();
}
inline const ::speech::sparrowhawk::Abbreviation& Token::abbreviation() const {
  return abbreviation_ != NULL ? *abbreviation_ : *default_instance_->abbreviation_;
}
inline ::speech::sparrowhawk::Abbreviation* Token::mutable_abbreviation() {
  set_has_abbreviation();
  if (abbreviation_ == NULL) abbreviation_ = new ::speech::sparrowhawk::Abbreviation;
  return abbreviation_;
}
inline ::speech::sparrowhawk::Abbreviation* Token::release_abbreviation() {
  clear_has_abbreviation();
  ::speech::sparrowhawk::Abbreviation* temp = abbreviation_;
  abbreviation_ = NULL;
  return temp;
}
inline void Token::set_allocated_abbreviation(::speech::sparrowhawk::Abbreviation* abbreviation) {
  delete abbreviation_;
  abbreviation_ = abbreviation;
  if (abbreviation) {
    set_has_abbreviation();
  } else {
    clear_has_abbreviation();
  }
}

// optional int32 first_daughter = 30;
inline bool Token::has_first_daughter() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Token::set_has_first_daughter() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Token::clear_has_first_daughter() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Token::clear_first_daughter() {
  first_daughter_ = 0;
  clear_has_first_daughter();
}
inline ::google::protobuf::int32 Token::first_daughter() const {
  return first_daughter_;
}
inline void Token::set_first_daughter(::google::protobuf::int32 value) {
  set_has_first_daughter();
  first_daughter_ = value;
}

// optional int32 last_daughter = 31;
inline bool Token::has_last_daughter() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Token::set_has_last_daughter() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Token::clear_has_last_daughter() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Token::clear_last_daughter() {
  last_daughter_ = 0;
  clear_has_last_daughter();
}
inline ::google::protobuf::int32 Token::last_daughter() const {
  return last_daughter_;
}
inline void Token::set_last_daughter(::google::protobuf::int32 value) {
  set_has_last_daughter();
  last_daughter_ = value;
}

// -------------------------------------------------------------------

// Word

// optional .speech.sparrowhawk.Links links = 1;
inline bool Word::has_links() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Word::set_has_links() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Word::clear_has_links() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Word::clear_links() {
  if (links_ != NULL) links_->::speech::sparrowhawk::Links::Clear();
  clear_has_links();
}
inline const ::speech::sparrowhawk::Links& Word::links() const {
  return links_ != NULL ? *links_ : *default_instance_->links_;
}
inline ::speech::sparrowhawk::Links* Word::mutable_links() {
  set_has_links();
  if (links_ == NULL) links_ = new ::speech::sparrowhawk::Links;
  return links_;
}
inline ::speech::sparrowhawk::Links* Word::release_links() {
  clear_has_links();
  ::speech::sparrowhawk::Links* temp = links_;
  links_ = NULL;
  return temp;
}
inline void Word::set_allocated_links(::speech::sparrowhawk::Links* links) {
  delete links_;
  links_ = links;
  if (links) {
    set_has_links();
  } else {
    clear_has_links();
  }
}

// optional string id = 2;
inline bool Word::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Word::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Word::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Word::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Word::id() const {
  return *id_;
}
inline void Word::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Word::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Word::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Word::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Word::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Word::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string spelling = 3;
inline bool Word::has_spelling() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Word::set_has_spelling() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Word::clear_has_spelling() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Word::clear_spelling() {
  if (spelling_ != &::google::protobuf::internal::kEmptyString) {
    spelling_->clear();
  }
  clear_has_spelling();
}
inline const ::std::string& Word::spelling() const {
  return *spelling_;
}
inline void Word::set_spelling(const ::std::string& value) {
  set_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    spelling_ = new ::std::string;
  }
  spelling_->assign(value);
}
inline void Word::set_spelling(const char* value) {
  set_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    spelling_ = new ::std::string;
  }
  spelling_->assign(value);
}
inline void Word::set_spelling(const char* value, size_t size) {
  set_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    spelling_ = new ::std::string;
  }
  spelling_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Word::mutable_spelling() {
  set_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    spelling_ = new ::std::string;
  }
  return spelling_;
}
inline ::std::string* Word::release_spelling() {
  clear_has_spelling();
  if (spelling_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spelling_;
    spelling_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Word::set_allocated_spelling(::std::string* spelling) {
  if (spelling_ != &::google::protobuf::internal::kEmptyString) {
    delete spelling_;
  }
  if (spelling) {
    set_has_spelling();
    spelling_ = spelling;
  } else {
    clear_has_spelling();
    spelling_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float pause_length = 4;
inline bool Word::has_pause_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Word::set_has_pause_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Word::clear_has_pause_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Word::clear_pause_length() {
  pause_length_ = 0;
  clear_has_pause_length();
}
inline float Word::pause_length() const {
  return pause_length_;
}
inline void Word::set_pause_length(float value) {
  set_has_pause_length();
  pause_length_ = value;
}

// optional bool precedes_pause = 5;
inline bool Word::has_precedes_pause() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Word::set_has_precedes_pause() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Word::clear_has_precedes_pause() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Word::clear_precedes_pause() {
  precedes_pause_ = false;
  clear_has_precedes_pause();
}
inline bool Word::precedes_pause() const {
  return precedes_pause_;
}
inline void Word::set_precedes_pause(bool value) {
  set_has_precedes_pause();
  precedes_pause_ = value;
}

// optional int32 parent = 6;
inline bool Word::has_parent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Word::set_has_parent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Word::clear_has_parent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Word::clear_parent() {
  parent_ = 0;
  clear_has_parent();
}
inline ::google::protobuf::int32 Word::parent() const {
  return parent_;
}
inline void Word::set_parent(::google::protobuf::int32 value) {
  set_has_parent();
  parent_ = value;
}

// -------------------------------------------------------------------

// LinguisticStructure

// optional int64 id = 1;
inline bool LinguisticStructure::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinguisticStructure::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinguisticStructure::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinguisticStructure::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 LinguisticStructure::id() const {
  return id_;
}
inline void LinguisticStructure::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional string input = 2;
inline bool LinguisticStructure::has_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinguisticStructure::set_has_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinguisticStructure::clear_has_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinguisticStructure::clear_input() {
  if (input_ != &::google::protobuf::internal::kEmptyString) {
    input_->clear();
  }
  clear_has_input();
}
inline const ::std::string& LinguisticStructure::input() const {
  return *input_;
}
inline void LinguisticStructure::set_input(const ::std::string& value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void LinguisticStructure::set_input(const char* value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void LinguisticStructure::set_input(const char* value, size_t size) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinguisticStructure::mutable_input() {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  return input_;
}
inline ::std::string* LinguisticStructure::release_input() {
  clear_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = input_;
    input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LinguisticStructure::set_allocated_input(::std::string* input) {
  if (input_ != &::google::protobuf::internal::kEmptyString) {
    delete input_;
  }
  if (input) {
    set_has_input();
    input_ = input;
  } else {
    clear_has_input();
    input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .speech.sparrowhawk.Token tokens = 3;
inline int LinguisticStructure::tokens_size() const {
  return tokens_.size();
}
inline void LinguisticStructure::clear_tokens() {
  tokens_.Clear();
}
inline const ::speech::sparrowhawk::Token& LinguisticStructure::tokens(int index) const {
  return tokens_.Get(index);
}
inline ::speech::sparrowhawk::Token* LinguisticStructure::mutable_tokens(int index) {
  return tokens_.Mutable(index);
}
inline ::speech::sparrowhawk::Token* LinguisticStructure::add_tokens() {
  return tokens_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token >&
LinguisticStructure::tokens() const {
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token >*
LinguisticStructure::mutable_tokens() {
  return &tokens_;
}

// repeated .speech.sparrowhawk.Word words = 4;
inline int LinguisticStructure::words_size() const {
  return words_.size();
}
inline void LinguisticStructure::clear_words() {
  words_.Clear();
}
inline const ::speech::sparrowhawk::Word& LinguisticStructure::words(int index) const {
  return words_.Get(index);
}
inline ::speech::sparrowhawk::Word* LinguisticStructure::mutable_words(int index) {
  return words_.Mutable(index);
}
inline ::speech::sparrowhawk::Word* LinguisticStructure::add_words() {
  return words_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word >&
LinguisticStructure::words() const {
  return words_;
}
inline ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word >*
LinguisticStructure::mutable_words() {
  return &words_;
}

// -------------------------------------------------------------------

// Utterance

// optional uint64 id = 1;
inline bool Utterance::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Utterance::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Utterance::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Utterance::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Utterance::id() const {
  return id_;
}
inline void Utterance::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string filename = 2;
inline bool Utterance::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Utterance::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Utterance::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Utterance::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Utterance::filename() const {
  return *filename_;
}
inline void Utterance::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Utterance::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Utterance::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Utterance::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* Utterance::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Utterance::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sentence = 3;
inline bool Utterance::has_sentence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Utterance::set_has_sentence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Utterance::clear_has_sentence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Utterance::clear_sentence() {
  if (sentence_ != &::google::protobuf::internal::kEmptyString) {
    sentence_->clear();
  }
  clear_has_sentence();
}
inline const ::std::string& Utterance::sentence() const {
  return *sentence_;
}
inline void Utterance::set_sentence(const ::std::string& value) {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::kEmptyString) {
    sentence_ = new ::std::string;
  }
  sentence_->assign(value);
}
inline void Utterance::set_sentence(const char* value) {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::kEmptyString) {
    sentence_ = new ::std::string;
  }
  sentence_->assign(value);
}
inline void Utterance::set_sentence(const char* value, size_t size) {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::kEmptyString) {
    sentence_ = new ::std::string;
  }
  sentence_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Utterance::mutable_sentence() {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::kEmptyString) {
    sentence_ = new ::std::string;
  }
  return sentence_;
}
inline ::std::string* Utterance::release_sentence() {
  clear_has_sentence();
  if (sentence_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sentence_;
    sentence_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Utterance::set_allocated_sentence(::std::string* sentence) {
  if (sentence_ != &::google::protobuf::internal::kEmptyString) {
    delete sentence_;
  }
  if (sentence) {
    set_has_sentence();
    sentence_ = sentence;
  } else {
    clear_has_sentence();
    sentence_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string original_sentence = 4;
inline bool Utterance::has_original_sentence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Utterance::set_has_original_sentence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Utterance::clear_has_original_sentence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Utterance::clear_original_sentence() {
  if (original_sentence_ != &::google::protobuf::internal::kEmptyString) {
    original_sentence_->clear();
  }
  clear_has_original_sentence();
}
inline const ::std::string& Utterance::original_sentence() const {
  return *original_sentence_;
}
inline void Utterance::set_original_sentence(const ::std::string& value) {
  set_has_original_sentence();
  if (original_sentence_ == &::google::protobuf::internal::kEmptyString) {
    original_sentence_ = new ::std::string;
  }
  original_sentence_->assign(value);
}
inline void Utterance::set_original_sentence(const char* value) {
  set_has_original_sentence();
  if (original_sentence_ == &::google::protobuf::internal::kEmptyString) {
    original_sentence_ = new ::std::string;
  }
  original_sentence_->assign(value);
}
inline void Utterance::set_original_sentence(const char* value, size_t size) {
  set_has_original_sentence();
  if (original_sentence_ == &::google::protobuf::internal::kEmptyString) {
    original_sentence_ = new ::std::string;
  }
  original_sentence_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Utterance::mutable_original_sentence() {
  set_has_original_sentence();
  if (original_sentence_ == &::google::protobuf::internal::kEmptyString) {
    original_sentence_ = new ::std::string;
  }
  return original_sentence_;
}
inline ::std::string* Utterance::release_original_sentence() {
  clear_has_original_sentence();
  if (original_sentence_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = original_sentence_;
    original_sentence_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Utterance::set_allocated_original_sentence(::std::string* original_sentence) {
  if (original_sentence_ != &::google::protobuf::internal::kEmptyString) {
    delete original_sentence_;
  }
  if (original_sentence) {
    set_has_original_sentence();
    original_sentence_ = original_sentence;
  } else {
    clear_has_original_sentence();
    original_sentence_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string segmenter_output = 5;
inline int Utterance::segmenter_output_size() const {
  return segmenter_output_.size();
}
inline void Utterance::clear_segmenter_output() {
  segmenter_output_.Clear();
}
inline const ::std::string& Utterance::segmenter_output(int index) const {
  return segmenter_output_.Get(index);
}
inline ::std::string* Utterance::mutable_segmenter_output(int index) {
  return segmenter_output_.Mutable(index);
}
inline void Utterance::set_segmenter_output(int index, const ::std::string& value) {
  segmenter_output_.Mutable(index)->assign(value);
}
inline void Utterance::set_segmenter_output(int index, const char* value) {
  segmenter_output_.Mutable(index)->assign(value);
}
inline void Utterance::set_segmenter_output(int index, const char* value, size_t size) {
  segmenter_output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Utterance::add_segmenter_output() {
  return segmenter_output_.Add();
}
inline void Utterance::add_segmenter_output(const ::std::string& value) {
  segmenter_output_.Add()->assign(value);
}
inline void Utterance::add_segmenter_output(const char* value) {
  segmenter_output_.Add()->assign(value);
}
inline void Utterance::add_segmenter_output(const char* value, size_t size) {
  segmenter_output_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Utterance::segmenter_output() const {
  return segmenter_output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Utterance::mutable_segmenter_output() {
  return &segmenter_output_;
}

// optional .speech.sparrowhawk.LinguisticStructure linguistic = 6;
inline bool Utterance::has_linguistic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Utterance::set_has_linguistic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Utterance::clear_has_linguistic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Utterance::clear_linguistic() {
  if (linguistic_ != NULL) linguistic_->::speech::sparrowhawk::LinguisticStructure::Clear();
  clear_has_linguistic();
}
inline const ::speech::sparrowhawk::LinguisticStructure& Utterance::linguistic() const {
  return linguistic_ != NULL ? *linguistic_ : *default_instance_->linguistic_;
}
inline ::speech::sparrowhawk::LinguisticStructure* Utterance::mutable_linguistic() {
  set_has_linguistic();
  if (linguistic_ == NULL) linguistic_ = new ::speech::sparrowhawk::LinguisticStructure;
  return linguistic_;
}
inline ::speech::sparrowhawk::LinguisticStructure* Utterance::release_linguistic() {
  clear_has_linguistic();
  ::speech::sparrowhawk::LinguisticStructure* temp = linguistic_;
  linguistic_ = NULL;
  return temp;
}
inline void Utterance::set_allocated_linguistic(::speech::sparrowhawk::LinguisticStructure* linguistic) {
  delete linguistic_;
  linguistic_ = linguistic;
  if (linguistic) {
    set_has_linguistic();
  } else {
    clear_has_linguistic();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sparrowhawk
}  // namespace speech

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speech::sparrowhawk::Token_Type>() {
  return ::speech::sparrowhawk::Token_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speech::sparrowhawk::Token_PauseLength>() {
  return ::speech::sparrowhawk::Token_PauseLength_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_items_2eproto__INCLUDED
